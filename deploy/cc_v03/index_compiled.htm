


<!--#########		 Crawling:.\index.htm		#########-->
	<html>
<head>
	<link rel="stylesheet" href="style/index.css" type="text/css"/>
	<script type="text/x-mathjax-config">

		MathJax.Hub.Config({
			extensions: ["tex2jax.js"],
			jax: ["input/TeX","output/HTML-CSS"],
			tex2jax: {inlineMath: [["$$","$$"],["$$$","$$$"]]},
			messageStyle: "none"
		});
	</script>
	<script type="text/javascript" src="../jslib/mathjax/MathJax.js"></script>
	<title> - Beam Calc - </title>
</head>
<body>
	<div id="apptitlebox" class="bmpblock">
		<div>Beam Calc</div>
		<button onclick="window.open('task/index.htm','_blank');">1. View Task</button>
		<button onclick="window.open('https://www.surveymonkey.com/s/FBLMLHG','_blank');">2. Do Survey :)</button>
	</div>
	<div style="display:flex;flex-wrap:wrap;justify-content:center;">	
		<div id="invardiv" class="bmpblock">
			<div style="width:100%;">
				<h2>General Variables</h2>
			</div>
			<div id="invardivdiv">
			</div>
			<div id="invardivtooltipbar" class="tooltipbar">
				.
			</div>
			<div id="invardiverrorbar">
				.
			</div>
		</div>
		<div id="varinfodiv" class="bmpblock" >
			<h2>Variable Reference Information</h2>
			<iframe id="varinfoiframe" src="infos/index.htm" style="border:none;width:calc(100% - 10px);height:460px;margin:5px;"></iframe>
		</div>
		<div id="reoinputoutputdiv" class="bmpblock">
			<div style="width:100%;">
				<h2>Reinforcement Information</h2>
			</div>
			<div id="reoinputdiv">
				<table class="reotable" style="">
					<thead>
						<tr style="font-family:sans-serif;">
							<td style="width:2em;"><img src="img/power_icon.png"/></td>
							<td style="width:3em;">bars</td>
							<td style="width:30px;border-left:none;"></td>
							<td style="width:3em;">area<br>(mm&sup2;)</td>
							<td>gap<br>(mm)</td>
							<td>position<br>(mm)</td>
							<td  style="width:2em;"><img src="img/sum_icon.png"/></td>
						</tr>
					</thead>
					<tbody id="reorows">
					</tbody>
				</table>
			</div>
			<div style="width:100%;"></div>
			<div id="reooutputdiv">
				<!-- TODO ressurect this-->
				<table id="reoouttable" style="width:100%" cellspacing=0>
					<thead>
						<tr>
							<th>Value:</th><th>Hover:</th><th>Sum/Avg</th><th>Unit:</th>
						</tr>
					</thead>
					<tbody>
						<tr data-tooltip="Depth measured from top surface of beam to centroid of layer[s].">
							<td id="depthlable">Depth from top surface:</td>
							<td>.</td>
							<td class="tableout" id="depth">1200</td>
							<td>mm</td>
						</tr>
						<tr data-tooltip="Cross-sectional area of reo-bar layer[s]">
							<td id="arealable">Cross-sectional area of steel:</td>
							<td>.</td>
							<td id="area" class="tableout">30000</td>
							<td>mm&#178;</td>
						</tr>
						<tr>
							<td id="amountlable">Number of bars</td>
							<td>10</td>
							<td id="number" class="tableout" data-tooltip="Number of reo bars in layer[s]">10</td>
							<td>bars</td>
						</tr>
						<tr>
							<td>.</td>
							<td>.</td>
							<td id="length" class="tableout" data-tooltip="Total length of reo bars based on clear span L_n with no overlap">10</td>
							<td>m</td>
						</tr>
						<tr>
							<td>.</td>
							<td>.</td>
							<td id="mass" class="tableout" data-tooltip="Total mass of layer[s]">400</td>
							<td>kg</td>
						</tr>
						<tr data-tooltip="Total tensile force in layer[s]. Compressive force is shown negative." >
							<td id="tforcelable" style="border-bottom:none;">Layer Tension Force:</td>
							<td>.</td>
							<td id="tforce" style="border-bottom:none;"  class="tableout">200</td>
							<td style="border-bottom:none;" >kN</td>
						</tr>
					</tbody>
				</table>
			</div>
			<div id="reoinputoutputtooltipbar" class="tooltipbar" style="height:4em;"></div>
		</div>
		<div id="crosssectiondiv" class="bmpblock" style="">
			<div style="width:100%;align-self:flex-start;">
				<h2>Cross Section</h2>
			</div>
			<canvas width="400" height="300" id="crosssectioncanvas" ></canvas>
		</div>
		<div style="flex: 1 0 500px;min-height:300px;margin-bottom:40px;" class="bmpblock">
			<div style="width:100%;">
				<h2>Calculations</h2>
			</div>
			<div id="calcdivcontent"></div>
		</div>
	</div>
</body>
<script>



// #########		 Crawling:.\main.js		#########
"use strict";



// #########		 Crawling:.\../jslib\Vector.js		#########

function Vector(x,y){
	this.x = x || 0;
	this.y = y || 0;

	this.set = function(x,y){
		this.x = x;
		this.y = y;
		return this;
	}.bind(this);

	this.fromVector = function(v){
		this.x = v.x;
		this.y = v.y;
		return this;
	}.bind(this);

	this.fromPoints = function(a,b){
		this.x = b.x-a.x;
		this.y = b.y-a.y;
		return this;
	}


	this.fromAngLen = function(angle,length){
		this.x = Math.cos(angle)*length;
		this.y = Math.sin(angle)*length;
		return this;
	}.bind(this);

	this.copy = function(){
		return new Vector(this.x,this.y);
	}.bind(this);
	this.duplicate = this.copy;

	this.plus = function(v){
		this.x+=v.x;
		this.y+=v.y;
		return this;
	}.bind(this);
	this.add = this.plus;

	this.plusScalar = function(s){
		this.x+=s;
		this.y+=s;
		return this;
	}.bind(this);
	this.addScalar = this.plusScalar;

	this.minus = function(v){
		this.x-=v.x;
		this.y-=v.y;
		return this;
	}.bind(this);
	this.subtract = this.minus;

	this.minusScalar = function(s){
		this.x-=s;
		this.y-=s;
		return this;
	}.bind(this);
	this.subtractScalar = this.minusScalar;

	this.scalar = function(s){
		this.x*=s;
		this.y*=s;
		return this;
	}.bind(this);

	this.dot = function(v){
		return  this.x*v.x + this.y*v.y;
	}.bind(this);

	this.left = function(){
		var tmpy = this.y;
		this.y = this.x;
		this.x = -tmpy;
		return this;
	}.bind(this);

	this.right = function(){
		var tmpy = this.y;
		this.y = -this.x;
		this.x = tmpy;
		return this;
	}.bind(this);

	this.unit = function(){
		var mag = this.len;
		this.x/=mag;
		this.y/=mag;
		return this;
	}.bind(this);

	Object.defineProperty(this,"lenSquared",{

		get:function(){
			return this.x*this.x + this.y*this.y;
		}.bind(this)
	});

	Object.defineProperty(this,"len",{

		get:function(){
			return Math.sqrt(this.lenSquared);
		}.bind(this)
	});

	Object.defineProperty(this,"ang",{

		get:function(){
			return Math.atan2(this.y,this.x);
		}.bind(this)
	});

	this.toString = function(){
		return "<"+this.x.toFixed(2)+", "+this.y.toFixed(2)+">";
	}.bind(this);

	this.rounded = function(){
		this.x =Math.round(this.x);
		this.y =Math.round(this.y);
		return this;
	}


	this.moveTo = function(ctx){
		ctx.moveTo(this.x,this.y);
		return this;
	}.bind(this);

	this.lineTo = function(ctx){
		ctx.lineTo(this.x,this.y);
		return this;
	}.bind(this);
}



// #########		 Crawling:.\drawBeam.js		#########



// #########		 Crawling:.\../jslib\CADCanvas.js		#########



// #########		 Crawling:.\../jslib\sylvester.src.js		#########
// === Sylvester ===
// Vector and Matrix mathematics modules for JavaScript
// Copyright (c) 2007 James Coglan
// 
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

var slvstr = (function (){
var exports = {};

var Sylvester = {
  version: '0.1.3',
  precision: 1e-6
};
function Vector() {}


Vector.prototype = {
  // Returns element i of the vector

  e: function(i) {
    return (i < 1 || i > this.elements.length) ? null : this.elements[i-1];
  },
  // Returns the number of elements the vector has

  dimensions: function() {
    return this.elements.length;
  },
  // Returns the modulus ('length') of the vector

  modulus: function() {
    return Math.sqrt(this.dot(this));
  },
  // Returns true iff the vector is equal to the argument

  eql: function(vector) {
    var n = this.elements.length;
    var V = vector.elements || vector;
    if (n != V.length) { return false; }


    do {
      if (Math.abs(this.elements[n-1] - V[n-1]) > Sylvester.precision) { return false; }

    } while (--n);
    return true;
  },
  // Returns a copy of the vector

  dup: function() {
    return Vector.create(this.elements);
  },
  // Maps the vector to another vector according to the given function

  map: function(fn) {
    var elements = [];

    this.each(function(x, i) {
      elements.push(fn(x, i));
    });
    return Vector.create(elements);
  },
  // Calls the iterator for each element of the vector in turn

  each: function(fn) {
    var n = this.elements.length, k = n, i;
    do { i = k - n;
      fn(this.elements[i], i+1);
    } while (--n);
  },
  // Returns a new vector created by normalizing the receiver

  toUnitVector: function() {
    var r = this.modulus();
    if (r === 0) { return this.dup(); }

    return this.map(function(x) { return x/r; });
  },
  // Returns the angle between the vector and the argument (also a vector)

  angleFrom: function(vector) {
    var V = vector.elements || vector;
    var n = this.elements.length, k = n, i;
    if (n != V.length) { return null; }

    var dot = 0, mod1 = 0, mod2 = 0;
    // Work things out in parallel to save time

    this.each(function(x, i) {
      dot += x * V[i-1];
      mod1 += x * x;
      mod2 += V[i-1] * V[i-1];
    });
    mod1 = Math.sqrt(mod1); mod2 = Math.sqrt(mod2);
    if (mod1*mod2 === 0) { return null; }

    var theta = dot / (mod1*mod2);
    if (theta < -1) { theta = -1; }

    if (theta > 1) { theta = 1; }

    return Math.acos(theta);
  },
  // Returns true iff the vector is parallel to the argument

  isParallelTo: function(vector) {
    var angle = this.angleFrom(vector);
    return (angle === null) ? null : (angle <= Sylvester.precision);
  },
  // Returns true iff the vector is antiparallel to the argument

  isAntiparallelTo: function(vector) {
    var angle = this.angleFrom(vector);
    return (angle === null) ? null : (Math.abs(angle - Math.PI) <= Sylvester.precision);
  },
  // Returns true iff the vector is perpendicular to the argument

  isPerpendicularTo: function(vector) {
    var dot = this.dot(vector);
    return (dot === null) ? null : (Math.abs(dot) <= Sylvester.precision);
  },
  // Returns the result of adding the argument to the vector

  add: function(vector) {
    var V = vector.elements || vector;
    if (this.elements.length != V.length) { return null; }

    return this.map(function(x, i) { return x + V[i-1]; });
  },
  // Returns the result of subtracting the argument from the vector

  subtract: function(vector) {
    var V = vector.elements || vector;
    if (this.elements.length != V.length) { return null; }

    return this.map(function(x, i) { return x - V[i-1]; });
  },
  // Returns the result of multiplying the elements of the vector by the argument

  multiply: function(k) {
    return this.map(function(x) { return x*k; });
  },
  x: function(k) { return this.multiply(k); },
  // Returns the scalar product of the vector with the argument
  // Both vectors must have equal dimensionality

  dot: function(vector) {
    var V = vector.elements || vector;
    var i, product = 0, n = this.elements.length;
    if (n != V.length) { return null; }

    do { product += this.elements[n-1] * V[n-1]; } while (--n);
    return product;
  },
  // Returns the vector product of the vector with the argument
  // Both vectors must have dimensionality 3

  cross: function(vector) {
    var B = vector.elements || vector;
    if (this.elements.length != 3 || B.length != 3) { return null; }

    var A = this.elements;
    return Vector.create([
      (A[1] * B[2]) - (A[2] * B[1]),
      (A[2] * B[0]) - (A[0] * B[2]),
      (A[0] * B[1]) - (A[1] * B[0])
    ]);
  },
  // Returns the (absolute) largest element of the vector

  max: function() {
    var m = 0, n = this.elements.length, k = n, i;
    do { i = k - n;
      if (Math.abs(this.elements[i]) > Math.abs(m)) { m = this.elements[i]; }

    } while (--n);
    return m;
  },
  // Returns the index of the first match found

  indexOf: function(x) {
    var index = null, n = this.elements.length, k = n, i;
    do { i = k - n;

      if (index === null && this.elements[i] == x) {
        index = i + 1;
      }

    } while (--n);
    return index;
  },
  // Returns a diagonal matrix with the vector's elements as its diagonal elements

  toDiagonalMatrix: function() {
    return Matrix.Diagonal(this.elements);
  },
  // Returns the result of rounding the elements of the vector

  round: function() {
    return this.map(function(x) { return Math.round(x); });
  },
  // Returns a copy of the vector with elements set to the given value if they
  // differ from it by less than Sylvester.precision

  snapTo: function(x) {

    return this.map(function(y) {
      return (Math.abs(y - x) <= Sylvester.precision) ? x : y;
    });
  },
  // Returns the vector's distance from the argument, when considered as a point in space

  distanceFrom: function(obj) {
    if (obj.anchor) { return obj.distanceFrom(this); }

    var V = obj.elements || obj;
    if (V.length != this.elements.length) { return null; }

    var sum = 0, part;

    this.each(function(x, i) {
      part = x - V[i-1];
      sum += part * part;
    });
    return Math.sqrt(sum);
  },
  // Returns true if the vector is point on the given line

  liesOn: function(line) {
    return line.contains(this);
  },
  // Return true iff the vector is a point in the given plane

  liesIn: function(plane) {
    return plane.contains(this);
  },
  // Rotates the vector about the given object. The object should be a 
  // point if the vector is 2D, and a line if it is 3D. Be careful with line directions!

  rotate: function(t, obj) {
    var V, R, x, y, z;

    switch (this.elements.length) {
      case 2:
        V = obj.elements || obj;
        if (V.length != 2) { return null; }

        R = Matrix.Rotation(t).elements;
        x = this.elements[0] - V[0];
        y = this.elements[1] - V[1];
        return Vector.create([
          V[0] + R[0][0] * x + R[0][1] * y,
          V[1] + R[1][0] * x + R[1][1] * y
        ]);
        break;
      case 3:
        if (!obj.direction) { return null; }

        var C = obj.pointClosestTo(this).elements;
        R = Matrix.Rotation(t, obj.direction).elements;
        x = this.elements[0] - C[0];
        y = this.elements[1] - C[1];
        z = this.elements[2] - C[2];
        return Vector.create([
          C[0] + R[0][0] * x + R[0][1] * y + R[0][2] * z,
          C[1] + R[1][0] * x + R[1][1] * y + R[1][2] * z,
          C[2] + R[2][0] * x + R[2][1] * y + R[2][2] * z
        ]);
        break;
      default:
        return null;
    }

  },
  // Returns the result of reflecting the point in the given point, line or plane

  reflectionIn: function(obj) {

    if (obj.anchor) {
      // obj is a plane or line
      var P = this.elements.slice();
      var C = obj.pointClosestTo(P).elements;
      return Vector.create([C[0] + (C[0] - P[0]), C[1] + (C[1] - P[1]), C[2] + (C[2] - (P[2] || 0))]);

    } else {
      // obj is a point
      var Q = obj.elements || obj;
      if (this.elements.length != Q.length) { return null; }

      return this.map(function(x, i) { return Q[i-1] + (Q[i-1] - x); });
    }

  },
  // Utility to make sure vectors are 3D. If they are 2D, a zero z-component is added

  to3D: function() {
    var V = this.dup();

    switch (V.elements.length) {
      case 3: break;
      case 2: V.elements.push(0); break;
      default: return null;
    }

    return V;
  },
  // Returns a string representation of the vector

  inspect: function() {
    return '[' + this.elements.join(', ') + ']';
  },
  // Set vector's elements from an array

  setElements: function(els) {
    this.elements = (els.elements || els).slice();
    return this;
  }

};
// Constructor function

Vector.create = function(elements) {
  var V = new Vector();
  return V.setElements(elements);
};
// i, j, k unit vectors
Vector.i = Vector.create([1,0,0]);
Vector.j = Vector.create([0,1,0]);
Vector.k = Vector.create([0,0,1]);
// Random vector of size n

Vector.Random = function(n) {
  var elements = [];
  do { elements.push(Math.random());
  } while (--n);
  return Vector.create(elements);
};
// Vector filled with zeros

Vector.Zero = function(n) {
  var elements = [];
  do { elements.push(0);
  } while (--n);
  return Vector.create(elements);
};
function Matrix() {}


Matrix.prototype = {
  // Returns element (i,j) of the matrix

  e: function(i,j) {
    if (i < 1 || i > this.elements.length || j < 1 || j > this.elements[0].length) { return null; }

    return this.elements[i-1][j-1];
  },
  // Returns row k of the matrix as a vector

  row: function(i) {
    if (i > this.elements.length) { return null; }

    return Vector.create(this.elements[i-1]);
  },
  // Returns column k of the matrix as a vector

  col: function(j) {
    if (j > this.elements[0].length) { return null; }

    var col = [], n = this.elements.length, k = n, i;
    do { i = k - n;
      col.push(this.elements[i][j-1]);
    } while (--n);
    return Vector.create(col);
  },
  // Returns the number of rows/columns the matrix has

  dimensions: function() {
    return {rows: this.elements.length, cols: this.elements[0].length};
  },
  // Returns the number of rows in the matrix

  rows: function() {
    return this.elements.length;
  },
  // Returns the number of columns in the matrix

  cols: function() {
    return this.elements[0].length;
  },
  // Returns true iff the matrix is equal to the argument. You can supply
  // a vector as the argument, in which case the receiver must be a
  // one-column matrix equal to the vector.

  eql: function(matrix) {
    var M = matrix.elements || matrix;
    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }

    if (this.elements.length != M.length ||
        this.elements[0].length != M[0].length) { return false; }

    var ni = this.elements.length, ki = ni, i, nj, kj = this.elements[0].length, j;
    do { i = ki - ni;
      nj = kj;
      do { j = kj - nj;
        if (Math.abs(this.elements[i][j] - M[i][j]) > Sylvester.precision) { return false; }

      } while (--nj);
    } while (--ni);
    return true;
  },
  // Returns a copy of the matrix

  dup: function() {
    return Matrix.create(this.elements);
  },
  // Maps the matrix to another matrix (of the same dimensions) according to the given function

  map: function(fn) {
    var els = [], ni = this.elements.length, ki = ni, i, nj, kj = this.elements[0].length, j;
    do { i = ki - ni;
      nj = kj;
      els[i] = [];
      do { j = kj - nj;
        els[i][j] = fn(this.elements[i][j], i + 1, j + 1);
      } while (--nj);
    } while (--ni);
    return Matrix.create(els);
  },
  // Returns true iff the argument has the same dimensions as the matrix

  isSameSizeAs: function(matrix) {
    var M = matrix.elements || matrix;
    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }

    return (this.elements.length == M.length &&
        this.elements[0].length == M[0].length);
  },
  // Returns the result of adding the argument to the matrix

  add: function(matrix) {
    var M = matrix.elements || matrix;
    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }

    if (!this.isSameSizeAs(M)) { return null; }

    return this.map(function(x, i, j) { return x + M[i-1][j-1]; });
  },
  // Returns the result of subtracting the argument from the matrix

  subtract: function(matrix) {
    var M = matrix.elements || matrix;
    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }

    if (!this.isSameSizeAs(M)) { return null; }

    return this.map(function(x, i, j) { return x - M[i-1][j-1]; });
  },
  // Returns true iff the matrix can multiply the argument from the left

  canMultiplyFromLeft: function(matrix) {
    var M = matrix.elements || matrix;
    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }

    // this.columns should equal matrix.rows
    return (this.elements[0].length == M.length);
  },
  // Returns the result of multiplying the matrix from the right by the argument.
  // If the argument is a scalar then just multiply all the elements. If the argument is
  // a vector, a vector is returned, which saves you having to remember calling
  // col(1) on the result.

  multiply: function(matrix) {

    if (!matrix.elements) {
      return this.map(function(x) { return x * matrix; });
    }

    var returnVector = matrix.modulus ? true : false;
    var M = matrix.elements || matrix;
    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }

    if (!this.canMultiplyFromLeft(M)) { return null; }

    var ni = this.elements.length, ki = ni, i, nj, kj = M[0].length, j;
    var cols = this.elements[0].length, elements = [], sum, nc, c;
    do { i = ki - ni;
      elements[i] = [];
      nj = kj;
      do { j = kj - nj;
        sum = 0;
        nc = cols;
        do { c = cols - nc;
          sum += this.elements[i][c] * M[c][j];
        } while (--nc);
        elements[i][j] = sum;
      } while (--nj);
    } while (--ni);
    var M = Matrix.create(elements);
    return returnVector ? M.col(1) : M;
  },
  x: function(matrix) { return this.multiply(matrix); },
  // Returns a submatrix taken from the matrix
  // Argument order is: start row, start col, nrows, ncols
  // Element selection wraps if the required index is outside the matrix's bounds, so you could
  // use this to perform row/column cycling or copy-augmenting.

  minor: function(a, b, c, d) {
    var elements = [], ni = c, i, nj, j;
    var rows = this.elements.length, cols = this.elements[0].length;
    do { i = c - ni;
      elements[i] = [];
      nj = d;
      do { j = d - nj;
        elements[i][j] = this.elements[(a+i-1)%rows][(b+j-1)%cols];
      } while (--nj);
    } while (--ni);
    return Matrix.create(elements);
  },
  // Returns the transpose of the matrix

  transpose: function() {
    var rows = this.elements.length, cols = this.elements[0].length;
    var elements = [], ni = cols, i, nj, j;
    do { i = cols - ni;
      elements[i] = [];
      nj = rows;
      do { j = rows - nj;
        elements[i][j] = this.elements[j][i];
      } while (--nj);
    } while (--ni);
    return Matrix.create(elements);
  },
  // Returns true iff the matrix is square

  isSquare: function() {
    return (this.elements.length == this.elements[0].length);
  },
  // Returns the (absolute) largest element of the matrix

  max: function() {
    var m = 0, ni = this.elements.length, ki = ni, i, nj, kj = this.elements[0].length, j;
    do { i = ki - ni;
      nj = kj;
      do { j = kj - nj;
        if (Math.abs(this.elements[i][j]) > Math.abs(m)) { m = this.elements[i][j]; }

      } while (--nj);
    } while (--ni);
    return m;
  },
  // Returns the indeces of the first match found by reading row-by-row from left to right

  indexOf: function(x) {
    var index = null, ni = this.elements.length, ki = ni, i, nj, kj = this.elements[0].length, j;
    do { i = ki - ni;
      nj = kj;
      do { j = kj - nj;
        if (this.elements[i][j] == x) { return {i: i+1, j: j+1}; }

      } while (--nj);
    } while (--ni);
    return null;
  },
  // If the matrix is square, returns the diagonal elements as a vector.
  // Otherwise, returns null.

  diagonal: function() {
    if (!this.isSquare) { return null; }

    var els = [], n = this.elements.length, k = n, i;
    do { i = k - n;
      els.push(this.elements[i][i]);
    } while (--n);
    return Vector.create(els);
  },
  // Make the matrix upper (right) triangular by Gaussian elimination.
  // This method only adds multiples of rows to other rows. No rows are
  // scaled up or switched, and the determinant is preserved.

  toRightTriangular: function() {
    var M = this.dup(), els;
    var n = this.elements.length, k = n, i, np, kp = this.elements[0].length, p;
    do { i = k - n;

      if (M.elements[i][i] == 0) {

        for (j = i + 1; j < k; j++) {

          if (M.elements[j][i] != 0) {
            els = []; np = kp;
            do { p = kp - np;
              els.push(M.elements[i][p] + M.elements[j][p]);
            } while (--np);
            M.elements[i] = els;
            break;
          }

        }

      }


      if (M.elements[i][i] != 0) {

        for (j = i + 1; j < k; j++) {
          var multiplier = M.elements[j][i] / M.elements[i][i];
          els = []; np = kp;
          do { p = kp - np;
            // Elements with column numbers up to an including the number
            // of the row that we're subtracting can safely be set straight to
            // zero, since that's the point of this routine and it avoids having
            // to loop over and correct rounding errors later
            els.push(p <= i ? 0 : M.elements[j][p] - M.elements[i][p] * multiplier);
          } while (--np);
          M.elements[j] = els;
        }

      }

    } while (--n);
    return M;
  },
  toUpperTriangular: function() { return this.toRightTriangular(); },
  // Returns the determinant for square matrices

  determinant: function() {
    if (!this.isSquare()) { return null; }

    var M = this.toRightTriangular();
    var det = M.elements[0][0], n = M.elements.length - 1, k = n, i;
    do { i = k - n + 1;
      det = det * M.elements[i][i];
    } while (--n);
    return det;
  },
  det: function() { return this.determinant(); },
  // Returns true iff the matrix is singular

  isSingular: function() {
    return (this.isSquare() && this.determinant() === 0);
  },
  // Returns the trace for square matrices

  trace: function() {
    if (!this.isSquare()) { return null; }

    var tr = this.elements[0][0], n = this.elements.length - 1, k = n, i;
    do { i = k - n + 1;
      tr += this.elements[i][i];
    } while (--n);
    return tr;
  },
  tr: function() { return this.trace(); },
  // Returns the rank of the matrix

  rank: function() {
    var M = this.toRightTriangular(), rank = 0;
    var ni = this.elements.length, ki = ni, i, nj, kj = this.elements[0].length, j;
    do { i = ki - ni;
      nj = kj;
      do { j = kj - nj;
        if (Math.abs(M.elements[i][j]) > Sylvester.precision) { rank++; break; }

      } while (--nj);
    } while (--ni);
    return rank;
  },
  rk: function() { return this.rank(); },
  // Returns the result of attaching the given argument to the right-hand side of the matrix

  augment: function(matrix) {
    var M = matrix.elements || matrix;
    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }

    var T = this.dup(), cols = T.elements[0].length;
    var ni = T.elements.length, ki = ni, i, nj, kj = M[0].length, j;
    if (ni != M.length) { return null; }

    do { i = ki - ni;
      nj = kj;
      do { j = kj - nj;
        T.elements[i][cols + j] = M[i][j];
      } while (--nj);
    } while (--ni);
    return T;
  },
  // Returns the inverse (if one exists) using Gauss-Jordan

  inverse: function() {
    if (!this.isSquare() || this.isSingular()) { return null; }

    var ni = this.elements.length, ki = ni, i, j;
    var M = this.augment(Matrix.I(ni)).toRightTriangular();
    var np, kp = M.elements[0].length, p, els, divisor;
    var inverse_elements = [], new_element;
    // Matrix is non-singular so there will be no zeros on the diagonal
    // Cycle through rows from last to first
    do { i = ni - 1;
      // First, normalise diagonal elements to 1
      els = []; np = kp;
      inverse_elements[i] = [];
      divisor = M.elements[i][i];
      do { p = kp - np;
        new_element = M.elements[i][p] / divisor;
        els.push(new_element);
        // Shuffle of the current row of the right hand side into the results
        // array as it will not be modified by later runs through this loop
        if (p >= ki) { inverse_elements[i].push(new_element); }

      } while (--np);
      M.elements[i] = els;
      // Then, subtract this row from those above it to
      // give the identity matrix on the left hand side

      for (j = 0; j < i; j++) {
        els = []; np = kp;
        do { p = kp - np;
          els.push(M.elements[j][p] - M.elements[i][p] * M.elements[j][i]);
        } while (--np);
        M.elements[j] = els;
      }

    } while (--ni);
    return Matrix.create(inverse_elements);
  },
  inv: function() { return this.inverse(); },
  // Returns the result of rounding all the elements

  round: function() {
    return this.map(function(x) { return Math.round(x); });
  },
  // Returns a copy of the matrix with elements set to the given value if they
  // differ from it by less than Sylvester.precision

  snapTo: function(x) {

    return this.map(function(p) {
      return (Math.abs(p - x) <= Sylvester.precision) ? x : p;
    });
  },
  // Returns a string representation of the matrix

  inspect: function() {
    var matrix_rows = [];
    var n = this.elements.length, k = n, i;
    do { i = k - n;
      matrix_rows.push(Vector.create(this.elements[i]).inspect());
    } while (--n);
    return matrix_rows.join('\n');
  },
  // Set the matrix's elements from an array. If the argument passed
  // is a vector, the resulting matrix will be a single column.

  setElements: function(els) {
    var i, elements = els.elements || els;

    if (typeof(elements[0][0]) != 'undefined') {
      var ni = elements.length, ki = ni, nj, kj, j;
      this.elements = [];
      do { i = ki - ni;
        nj = elements[i].length; kj = nj;
        this.elements[i] = [];
        do { j = kj - nj;
          this.elements[i][j] = elements[i][j];
        } while (--nj);
      } while(--ni);
      return this;
    }

    var n = elements.length, k = n;
    this.elements = [];
    do { i = k - n;
      this.elements.push([elements[i]]);
    } while (--n);
    return this;
  }

};
// Constructor function

Matrix.create = function(elements) {
  var M = new Matrix();
  return M.setElements(elements);
};
// Identity matrix of size n

Matrix.I = function(n) {
  var els = [], k = n, i, nj, j;
  do { i = k - n;
    els[i] = []; nj = k;
    do { j = k - nj;
      els[i][j] = (i == j) ? 1 : 0;
    } while (--nj);
  } while (--n);
  return Matrix.create(els);
};
// Diagonal matrix - all off-diagonal elements are zero

Matrix.Diagonal = function(elements) {
  var n = elements.length, k = n, i;
  var M = Matrix.I(n);
  do { i = k - n;
    M.elements[i][i] = elements[i];
  } while (--n);
  return M;
};
// Rotation matrix about some axis. If no axis is
// supplied, assume we're after a 2D transform

Matrix.Rotation = function(theta, a) {

  if (!a) {
    return Matrix.create([
      [Math.cos(theta),  -Math.sin(theta)],
      [Math.sin(theta),   Math.cos(theta)]
    ]);
  }

  var axis = a.dup();
  if (axis.elements.length != 3) { return null; }

  var mod = axis.modulus();
  var x = axis.elements[0]/mod, y = axis.elements[1]/mod, z = axis.elements[2]/mod;
  var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;
  // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp
  // That proof rotates the co-ordinate system so theta
  // becomes -theta and sin becomes -sin here.
  return Matrix.create([
    [ t*x*x + c, t*x*y - s*z, t*x*z + s*y ],
    [ t*x*y + s*z, t*y*y + c, t*y*z - s*x ],
    [ t*x*z - s*y, t*y*z + s*x, t*z*z + c ]
  ]);
};
// Special case rotations

Matrix.RotationX = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  1,  0,  0 ],
    [  0,  c, -s ],
    [  0,  s,  c ]
  ]);
};

Matrix.RotationY = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  c,  0,  s ],
    [  0,  1,  0 ],
    [ -s,  0,  c ]
  ]);
};

Matrix.RotationZ = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  c, -s,  0 ],
    [  s,  c,  0 ],
    [  0,  0,  1 ]
  ]);
};
// Random matrix of n rows, m columns

Matrix.Random = function(n, m) {
  return Matrix.Zero(n, m).map(
    function() { return Math.random(); }

  );
};
// Matrix filled with zeros

Matrix.Zero = function(n, m) {
  var els = [], ni = n, i, nj, j;
  do { i = n - ni;
    els[i] = [];
    nj = m;
    do { j = m - nj;
      els[i][j] = 0;
    } while (--nj);
  } while (--ni);
  return Matrix.create(els);
};
function Line() {}


Line.prototype = {
  // Returns true if the argument occupies the same space as the line

  eql: function(line) {
    return (this.isParallelTo(line) && this.contains(line.anchor));
  },
  // Returns a copy of the line

  dup: function() {
    return Line.create(this.anchor, this.direction);
  },
  // Returns the result of translating the line by the given vector/array

  translate: function(vector) {
    var V = vector.elements || vector;
    return Line.create([
      this.anchor.elements[0] + V[0],
      this.anchor.elements[1] + V[1],
      this.anchor.elements[2] + (V[2] || 0)
    ], this.direction);
  },
  // Returns true if the line is parallel to the argument. Here, 'parallel to'
  // means that the argument's direction is either parallel or antiparallel to
  // the line's own direction. A line is parallel to a plane if the two do not
  // have a unique intersection.

  isParallelTo: function(obj) {
    if (obj.normal) { return obj.isParallelTo(this); }

    var theta = this.direction.angleFrom(obj.direction);
    return (Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision);
  },
  // Returns the line's perpendicular distance from the argument,
  // which can be a point, a line or a plane

  distanceFrom: function(obj) {
    if (obj.normal) { return obj.distanceFrom(this); }


    if (obj.direction) {
      // obj is a line
      if (this.isParallelTo(obj)) { return this.distanceFrom(obj.anchor); }

      var N = this.direction.cross(obj.direction).toUnitVector().elements;
      var A = this.anchor.elements, B = obj.anchor.elements;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);

    } else {
      // obj is a point
      var P = obj.elements || obj;
      var A = this.anchor.elements, D = this.direction.elements;
      var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];
      var modPA = Math.sqrt(PA1*PA1 + PA2*PA2 + PA3*PA3);
      if (modPA === 0) return 0;
      // Assumes direction vector is normalized
      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;
      var sin2 = 1 - cosTheta*cosTheta;
      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));
    }

  },
  // Returns true iff the argument is a point on the line

  contains: function(point) {
    var dist = this.distanceFrom(point);
    return (dist !== null && dist <= Sylvester.precision);
  },
  // Returns true iff the line lies in the given plane

  liesIn: function(plane) {
    return plane.contains(this);
  },
  // Returns true iff the line has a unique point of intersection with the argument

  intersects: function(obj) {
    if (obj.normal) { return obj.intersects(this); }

    return (!this.isParallelTo(obj) && this.distanceFrom(obj) <= Sylvester.precision);
  },
  // Returns the unique intersection point with the argument, if one exists

  intersectionWith: function(obj) {
    if (obj.normal) { return obj.intersectionWith(this); }

    if (!this.intersects(obj)) { return null; }

    var P = this.anchor.elements, X = this.direction.elements,
        Q = obj.anchor.elements, Y = obj.direction.elements;
    var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];
    var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];
    var XdotQsubP = - X1*PsubQ1 - X2*PsubQ2 - X3*PsubQ3;
    var YdotPsubQ = Y1*PsubQ1 + Y2*PsubQ2 + Y3*PsubQ3;
    var XdotX = X1*X1 + X2*X2 + X3*X3;
    var YdotY = Y1*Y1 + Y2*Y2 + Y3*Y3;
    var XdotY = X1*Y1 + X2*Y2 + X3*Y3;
    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);
    return Vector.create([P[0] + k*X1, P[1] + k*X2, P[2] + k*X3]);
  },
  // Returns the point on the line that is closest to the given point or line

  pointClosestTo: function(obj) {

    if (obj.direction) {
      // obj is a line
      if (this.intersects(obj)) { return this.intersectionWith(obj); }

      if (this.isParallelTo(obj)) { return null; }

      var D = this.direction.elements, E = obj.direction.elements;
      var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];
      // Create plane containing obj and the shared normal and intersect this with it
      // Thank you: http://www.cgafaq.info/wiki/Line-line_distance
      var x = (D3 * E1 - D1 * E3), y = (D1 * E2 - D2 * E1), z = (D2 * E3 - D3 * E2);
      var N = Vector.create([x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1]);
      var P = Plane.create(obj.anchor, N);
      return P.intersectionWith(this);

    } else {
      // obj is a point
      var P = obj.elements || obj;
      if (this.contains(P)) { return Vector.create(P); }

      var A = this.anchor.elements, D = this.direction.elements;
      var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];
      var x = D1 * (P[1]-A2) - D2 * (P[0]-A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1]-A2),
          z = D3 * (P[0]-A1) - D1 * ((P[2] || 0) - A3);
      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);
      var k = this.distanceFrom(P) / V.modulus();
      return Vector.create([
        P[0] + V.elements[0] * k,
        P[1] + V.elements[1] * k,
        (P[2] || 0) + V.elements[2] * k
      ]);
    }

  },
  // Returns a copy of the line rotated by t radians about the given line. Works by
  // finding the argument's closest point to this line's anchor point (call this C) and
  // rotating the anchor about C. Also rotates the line's direction about the argument's.
  // Be careful with this - the rotation axis' direction affects the outcome!

  rotate: function(t, line) {
    // If we're working in 2D
    if (typeof(line.direction) == 'undefined') { line = Line.create(line.to3D(), Vector.k); }

    var R = Matrix.Rotation(t, line.direction).elements;
    var C = line.pointClosestTo(this.anchor).elements;
    var A = this.anchor.elements, D = this.direction.elements;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Line.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],
      R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],
      R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]
    ]);
  },
  // Returns the line's reflection in the given point or line

  reflectionIn: function(obj) {

    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.elements, D = this.direction.elements;
      var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];
      var newA = this.anchor.reflectionIn(obj).elements;
      // Add the line's direction vector to its anchor, then mirror that in the plane
      var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;
      var Q = obj.pointClosestTo([AD1, AD2, AD3]).elements;
      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];
      return Line.create(newA, newD);

    } else if (obj.direction) {
      // obj is a line - reflection obtained by rotating PI radians about obj
      return this.rotate(Math.PI, obj);

    } else {
      // obj is a point - just reflect the line's anchor in it
      var P = obj.elements || obj;
      return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);
    }

  },
  // Set the line's anchor point and direction.

  setVectors: function(anchor, direction) {
    // Need to do this so that line's properties are not
    // references to the arguments passed in
    anchor = Vector.create(anchor);
    direction = Vector.create(direction);
    if (anchor.elements.length == 2) {anchor.elements.push(0); }

    if (direction.elements.length == 2) { direction.elements.push(0); }

    if (anchor.elements.length > 3 || direction.elements.length > 3) { return null; }

    var mod = direction.modulus();
    if (mod === 0) { return null; }

    this.anchor = anchor;
    this.direction = Vector.create([
      direction.elements[0] / mod,
      direction.elements[1] / mod,
      direction.elements[2] / mod
    ]);
    return this;
  }

};
// Constructor function

Line.create = function(anchor, direction) {
  var L = new Line();
  return L.setVectors(anchor, direction);
};
// Axes
Line.X = Line.create(Vector.Zero(3), Vector.i);
Line.Y = Line.create(Vector.Zero(3), Vector.j);
Line.Z = Line.create(Vector.Zero(3), Vector.k);
function Plane() {}


Plane.prototype = {
  // Returns true iff the plane occupies the same space as the argument

  eql: function(plane) {
    return (this.contains(plane.anchor) && this.isParallelTo(plane));
  },
  // Returns a copy of the plane

  dup: function() {
    return Plane.create(this.anchor, this.normal);
  },
  // Returns the result of translating the plane by the given vector

  translate: function(vector) {
    var V = vector.elements || vector;
    return Plane.create([
      this.anchor.elements[0] + V[0],
      this.anchor.elements[1] + V[1],
      this.anchor.elements[2] + (V[2] || 0)
    ], this.normal);
  },
  // Returns true iff the plane is parallel to the argument. Will return true
  // if the planes are equal, or if you give a line and it lies in the plane.

  isParallelTo: function(obj) {
    var theta;

    if (obj.normal) {
      // obj is a plane
      theta = this.normal.angleFrom(obj.normal);
      return (Math.abs(theta) <= Sylvester.precision || Math.abs(Math.PI - theta) <= Sylvester.precision);

    } else if (obj.direction) {
      // obj is a line
      return this.normal.isPerpendicularTo(obj.direction);
    }

    return null;
  },
  // Returns true iff the receiver is perpendicular to the argument

  isPerpendicularTo: function(plane) {
    var theta = this.normal.angleFrom(plane.normal);
    return (Math.abs(Math.PI/2 - theta) <= Sylvester.precision);
  },
  // Returns the plane's distance from the given object (point, line or plane)

  distanceFrom: function(obj) {
    if (this.intersects(obj) || this.contains(obj)) { return 0; }


    if (obj.anchor) {
      // obj is a plane or line
      var A = this.anchor.elements, B = obj.anchor.elements, N = this.normal.elements;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);

    } else {
      // obj is a point
      var P = obj.elements || obj;
      var A = this.anchor.elements, N = this.normal.elements;
      return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);
    }

  },
  // Returns true iff the plane contains the given point or line

  contains: function(obj) {
    if (obj.normal) { return null; }


    if (obj.direction) {
      return (this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction)));

    } else {
      var P = obj.elements || obj;
      var A = this.anchor.elements, N = this.normal.elements;
      var diff = Math.abs(N[0]*(A[0] - P[0]) + N[1]*(A[1] - P[1]) + N[2]*(A[2] - (P[2] || 0)));
      return (diff <= Sylvester.precision);
    }

  },
  // Returns true iff the plane has a unique point/line of intersection with the argument

  intersects: function(obj) {
    if (typeof(obj.direction) == 'undefined' && typeof(obj.normal) == 'undefined') { return null; }

    return !this.isParallelTo(obj);
  },
  // Returns the unique intersection with the argument, if one exists. The result
  // will be a vector if a line is supplied, and a line if a plane is supplied.

  intersectionWith: function(obj) {
    if (!this.intersects(obj)) { return null; }


    if (obj.direction) {
      // obj is a line
      var A = obj.anchor.elements, D = obj.direction.elements,
          P = this.anchor.elements, N = this.normal.elements;
      var multiplier = (N[0]*(P[0]-A[0]) + N[1]*(P[1]-A[1]) + N[2]*(P[2]-A[2])) / (N[0]*D[0] + N[1]*D[1] + N[2]*D[2]);
      return Vector.create([A[0] + D[0]*multiplier, A[1] + D[1]*multiplier, A[2] + D[2]*multiplier]);

    } else if (obj.normal) {
      // obj is a plane
      var direction = this.normal.cross(obj.normal).toUnitVector();
      // To find an anchor point, we find one co-ordinate that has a value
      // of zero somewhere on the intersection, and remember which one we picked
      var N = this.normal.elements, A = this.anchor.elements,
          O = obj.normal.elements, B = obj.anchor.elements;
      var solver = Matrix.Zero(2,2), i = 0;

      while (solver.isSingular()) {
        i++;
        solver = Matrix.create([
          [ N[i%3], N[(i+1)%3] ],
          [ O[i%3], O[(i+1)%3]  ]
        ]);
      }

      // Then we solve the simultaneous equations in the remaining dimensions
      var inverse = solver.inverse().elements;
      var x = N[0]*A[0] + N[1]*A[1] + N[2]*A[2];
      var y = O[0]*B[0] + O[1]*B[1] + O[2]*B[2];
      var intersection = [
        inverse[0][0] * x + inverse[0][1] * y,
        inverse[1][0] * x + inverse[1][1] * y
      ];
      var anchor = [];

      for (var j = 1; j <= 3; j++) {
        // This formula picks the right element from intersection by
        // cycling depending on which element we set to zero above
        anchor.push((i == j) ? 0 : intersection[(j + (5 - i)%3)%3]);
      }

      return Line.create(anchor, direction);
    }

  },
  // Returns the point in the plane closest to the given point

  pointClosestTo: function(point) {
    var P = point.elements || point;
    var A = this.anchor.elements, N = this.normal.elements;
    var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];
    return Vector.create([P[0] + N[0] * dot, P[1] + N[1] * dot, (P[2] || 0) + N[2] * dot]);
  },
  // Returns a copy of the plane, rotated by t radians about the given line
  // See notes on Line#rotate.

  rotate: function(t, line) {
    var R = Matrix.Rotation(t, line.direction).elements;
    var C = line.pointClosestTo(this.anchor).elements;
    var A = this.anchor.elements, N = this.normal.elements;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Plane.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2],
      R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2],
      R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]
    ]);
  },
  // Returns the reflection of the plane in the given point, line or plane.

  reflectionIn: function(obj) {

    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.elements, N = this.normal.elements;
      var A1 = A[0], A2 = A[1], A3 = A[2], N1 = N[0], N2 = N[1], N3 = N[2];
      var newA = this.anchor.reflectionIn(obj).elements;
      // Add the plane's normal to its anchor, then mirror that in the other plane
      var AN1 = A1 + N1, AN2 = A2 + N2, AN3 = A3 + N3;
      var Q = obj.pointClosestTo([AN1, AN2, AN3]).elements;
      var newN = [Q[0] + (Q[0] - AN1) - newA[0], Q[1] + (Q[1] - AN2) - newA[1], Q[2] + (Q[2] - AN3) - newA[2]];
      return Plane.create(newA, newN);

    } else if (obj.direction) {
      // obj is a line
      return this.rotate(Math.PI, obj);

    } else {
      // obj is a point
      var P = obj.elements || obj;
      return Plane.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.normal);
    }

  },
  // Sets the anchor point and normal to the plane. If three arguments are specified,
  // the normal is calculated by assuming the three points should lie in the same plane.
  // If only two are sepcified, the second is taken to be the normal. Normal vector is
  // normalised before storage.

  setVectors: function(anchor, v1, v2) {
    anchor = Vector.create(anchor);
    anchor = anchor.to3D(); if (anchor === null) { return null; }

    v1 = Vector.create(v1);
    v1 = v1.to3D(); if (v1 === null) { return null; }


    if (typeof(v2) == 'undefined') {
      v2 = null;

    } else {
      v2 = Vector.create(v2);
      v2 = v2.to3D(); if (v2 === null) { return null; }

    }

    var A1 = anchor.elements[0], A2 = anchor.elements[1], A3 = anchor.elements[2];
    var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];
    var normal, mod;

    if (v2 !== null) {
      var v21 = v2.elements[0], v22 = v2.elements[1], v23 = v2.elements[2];
      normal = Vector.create([
        (v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2),
        (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3),
        (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)
      ]);
      mod = normal.modulus();
      if (mod === 0) { return null; }

      normal = Vector.create([normal.elements[0] / mod, normal.elements[1] / mod, normal.elements[2] / mod]);

    } else {
      mod = Math.sqrt(v11*v11 + v12*v12 + v13*v13);
      if (mod === 0) { return null; }

      normal = Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);
    }

    this.anchor = anchor;
    this.normal = normal;
    return this;
  }

};
// Constructor function

Plane.create = function(anchor, v1, v2) {
  var P = new Plane();
  return P.setVectors(anchor, v1, v2);
};
// X-Y-Z planes
Plane.XY = Plane.create(Vector.Zero(3), Vector.k);
Plane.YZ = Plane.create(Vector.Zero(3), Vector.i);
Plane.ZX = Plane.create(Vector.Zero(3), Vector.j);
Plane.YX = Plane.XY; Plane.ZY = Plane.YZ; Plane.XZ = Plane.ZX;
// Utility functions
var $V = Vector.create;
var $M = Matrix.create;
var $L = Line.create;
var $P = Plane.create;
exports.Sylvester = Sylvester;
exports.Vector	= Vector;
exports.Matrix	= Matrix;
exports.Line	= Line;
exports.Plane	= Plane;
return exports
})();

CanvasRenderingContext2D.prototype.moveToV = function(v){
	this.moveTo(v.x,v.y)
}


CanvasRenderingContext2D.prototype.lineToV = function(v){
	this.lineTo(v.x,v.y)
}


CanvasRenderingContext2D.prototype.arrow = function(from,to,size){
	this.beginPath();
	this.moveTo(from.x,from.y);
	this.lineTo(to.x,to.y);
	this.stroke();
	var ang = Math.atan2(to.y-from.y,to.x-from.x);
	this.save();
		this.translate(to.x,to.y);
		this.rotate(ang-Math.PI/2);
		this.beginPath();
		this.moveTo(-0.3*size,-1*size);
		this.lineTo( 0, 0  );
		this.lineTo( 0.3*size,-1*size);
		this.stroke();
	this.restore();
}

//		Circle drawing Functions

CanvasRenderingContext2D.prototype.circle = function(x,y,radius){
	this.arc(x,y,radius,0,Math.PI*2);
}


CanvasRenderingContext2D.prototype.fillCircle = function(x,y,radius){
	this.beginPath();
	this.circle(x,y,radius);
	this.fill();
}


CanvasRenderingContext2D.prototype.strokeCircle = function (x,y,radius) {
	this.beginPath();
	this.circle(x,y,radius);
	this.stroke();
}


CanvasRenderingContext2D.prototype.fillStrokeCircle = function(x,y,radius){
	this.beginPath();
	this.circle(x,y,radius);
	this.fill();
	this.stroke();
}

//		SHARP LINE

CanvasRenderingContext2D.prototype.sharpLine = function (aa, bb, cc, dd, r,g,b,a) {
	var v1 = {x:aa,y:bb};
	var v2 = {x:cc,y:dd};
	var x0 = Math.round(v1.x);
	var y0 = Math.round(v1.y);
	var x1 = Math.round(v2.x);
	var y1 = Math.round(v2.y);
	var imd = this.getImageData(0,0,this.canvas.width,this.canvas.height);
	var index;
	var dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
	var dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1; 
	var err = (dx>dy ? dx : -dy)/2;
	//var out = 0;

	while (true) {
		index = 4*x0 + (4*this.canvas.width)*y0;
		imd.data[index+0]	= r;
		imd.data[index+1]	= g;
		imd.data[index+2]	= b;
		imd.data[index+3]	= a;
		//this.setPixel(x0,y0,0,0,0,255);
		if (x0 === x1 && y0 === y1) break;
		var e2 = err;
		if (e2 > -dx) { err -= dy; x0 += sx; }

		if (e2 < dy) { err += dx; y0 += sy; }

	}

	//console.log(out);
  this.putImageData(imd,0,0);
}


CanvasRenderingContext2D.prototype.sharpLineV = function(v1,v2,r,g,b,a){
	this.sharpLine(v1.x,v1.y,v2.x,v2.y,r,g,b,a);
}

//		SET PIXEL

CanvasRenderingContext2D.prototype.setPixel = function (x,y, r,g,b,a) {
	var imd = this.getImageData(0,0,this.canvas.width,this.canvas.height);
	var index = 4*x + (4*this.canvas.width)*y;
	imd.data[index+0]	= r;
	imd.data[index+1]	= g;
	imd.data[index+2]	= b;
	imd.data[index+3]	= a;
	this.putImageData(imd,0,0);
}

function drawElevation(ctx, b){
	var maxwidth = ctx.canvas.width-200;
	var maxheight = ctx.canvas.height-10;
	var minwidth = 0;
	var minheight = 0;
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	ctx.save();
		ctx.translate(Math.floor(ctx.canvas.width/2), Math.floor(ctx.canvas.height/2));
		var scale = Math.min(maxwidth/b.Ln, maxheight/b.D);
		var w = b.Ln*scale;
		var h = b.D*scale;
		ctx.strokeStyle = "#333333";
		ctx.lineWidth = 2;
		ctx.strokeRect(-w/2,-h/2,w,h);
		dim(ctx,w/2,-h/2,w/2,h/2,0,10,"D = "+b.D+"mm");
		dim(ctx,-w/2,0 ,w/2,0,Math.PI/2,(h>40)?0.01:30,"L_n = "+b.Ln+"mm");
	ctx.restore();
}


function drawCrossSection(ctx, b){
	var maxwidth	= ctx.canvas.width-190;
	var maxheight	= ctx.canvas.height-80;	
	var scale = Math.min(maxwidth/b.b, maxheight/b.D);
	var w = scale*b.b;
	var h = scale*b.D;
	var scaled_cover = b.cover*scale;
	var scaled_dfitments = b.dfitments*scale;
	// TODO: update this with correct bend radii
	// AS3600 17.2.3 assuming N12 Bars
	var fitments_BendRadius = 6*b.df/2*scale; 
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	ctx.save();

	try{
		ctx.translate(Math.floor(ctx.canvas.width/2), Math.floor(ctx.canvas.height/2));
		// Draw beam crossection outline
		ctx.strokeStyle = "#333333";
		ctx.lineWidth = 2;
		ctx.strokeRect(Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
		// Breadth
		dim(ctx,-w/2,h/2,w/2,h/2, Math.PI/2, 12,b.b+" mm");
		// Depth
		dim(ctx,-w/2,-h/2,-w/2,h/2, 0, -12,b.D+" mm");
		//Cover
		dim(ctx,w/2,-h/2,w/2,-h/2+b.cover*scale, 0, 10,b.cover+" mm cover");
		// HIGH PRECISION MODE
		// TODO: find the reference for this:
		// AS3600 
		//ctx.rotate(Math.sin((new Date()).getTime()/7000)*Math.PI/180*1);
		//ctx.translate(
		//var placementtollerance = 10*scale;
		//	Math.sin((new Date()).getTime()/5000)*placementtollerance/2,
		//	Math.sin((new Date()).getTime()/3000)*placementtollerance/2
		//);
		// Draw Fitments
		// TODO: Draw in top two reo bars if not included in the prescribed reo.
		//ctx.fillStyle = "#777777";
		// Draw top two longitudinal reo bars.
		//ctx.fillCircle(-w/2+scaled_cover+scaled_dfitments, -h/2+scaled_cover+scaled_dfitments, scaled_dfitments/2);
		//ctx.fillCircle( w/2-scaled_cover-scaled_dfitments, -h/2+scaled_cover+scaled_dfitments, scaled_dfitments/2);
		console.log((-b.b/2 + b.cover + b.df/2)	*scale)
		drawFitment(ctx,
						(-b.b/2 + b.cover + b.df/2)	*scale,
						(-b.D/2 + b.cover + b.df/2)	*scale,
						(b.b - 2*b.cover - b.df)		*scale,
						(b.D - 2*b.cover - b.df)	*scale,
						fitments_BendRadius*scale,
						30*scale,
						b.df*scale);
		// Draw other reo bars

		for(var i = 0; i<b.reo.length; i++){
			var layer = b.reo[i];
			var scaled_dtendons = layer.diameter*scale;
			var offsety = layer.depth*scale;
			var offsetx = (b.cover + b.df + layer.diameter/2)*scale;
			var spacing = (b.b - 2*(b.cover + b.df) - layer.diameter)*scale/(layer.number-1);
			// TODO: hover highlight
			ctx.fillStyle = "black";

			for(j=0;j<layer.number;j++){
				ctx.fillCircle( offsetx+j*spacing-w/2, offsety-h/2, scaled_dtendons/2);
			}

			ctx.fillStyle = "black";
			ctx.textAlign = "start";
			ctx.textBaseline = "middle";
			ctx.fillText(layer.number+"N"+layer.diameter,w/2+10,  offsety-h/2);
		}	

	}catch(e){
		ctx.restore();
		throw e;
	}

}


function drawFitment(ctx,x,y,w,h,rad,fitmentlen,scaled_dfitments){
console.log(x,y,w,h,rad,fitmentlen,scaled_dfitments)

	if(true){
	console.log("d")
		ctx.lineCap = "square";
		ctx.strokeStyle = "black";
		ctx.lineWidth = Math.ceil(scaled_dfitments);
		do_draw();
		ctx.lineCap = "square";
		ctx.strokeStyle = "white";
		ctx.lineWidth = Math.ceil(scaled_dfitments)-2;
		do_draw();
		do_draw();

	}else{
		ctx.lineCap = "round";
		ctx.strokeStyle = "black";
		ctx.lineWidth = 0.5;// Math.max(0.5,Math.floor(scaled_dfitments));
		draw1();
		draw2();
	}


	function do_draw(){
		ctx.beginPath();
			ctx.moveTo(x+w-rad-rad/Math.SQRT2-fitmentlen,y+rad-rad/Math.SQRT2+fitmentlen);
			ctx.arc(x+w-rad,y+rad, rad, Math.PI*1.5-Math.PI/4, Math.PI*2);
			ctx.moveTo(x+w,y+h-rad);
			ctx.lineTo(x+w,y+rad);
			ctx.arc(x+w-rad,y+h-rad,rad,0,Math.PI/2)
			ctx.lineTo(x+w-rad*3,y+h)
			ctx.moveTo(x+w-rad,y+h);
			ctx.lineTo(x+rad,y+h);
			ctx.arc(x+rad,y+h-rad,rad,Math.PI/2,Math.PI)
			ctx.moveTo(x,y+h-rad);
			ctx.lineTo(x,y+rad);
			ctx.arc(x+rad,y+rad,rad,Math.PI,Math.PI*1.5)
			ctx.moveTo(x+rad,y);
			ctx.lineTo(x+w-rad,y);
			ctx.arc(x+w-rad,y+rad, rad, -Math.PI/2, Math.PI/4);
			ctx.lineTo(x+w-rad+rad/Math.SQRT2-fitmentlen,y+rad+rad/Math.SQRT2+fitmentlen);
		ctx.stroke();
	}

}

			//ctx.arc(x+rad,y+h-rad,rad,Math.PI/2,Math.PI)
			//ctx.moveTo(x,y+h-rad);
			//ctx.lineTo(x,y+rad);
			//ctx.arc(x+rad,y+rad,rad,Math.PI,Math.PI*1.5)
			//ctx.moveTo(x+rad,y);
			//ctx.lineTo(x+w-rad,y);

function dim(ctx,x1,y1,x2,y2,angle,dist,txt){
	var fontpx = 15;
	ctx.save();
	ctx.font = fontpx+"px serif";
	ctx.textBaseline="middle"
	ctx.textAlign="center"
	var metric = ctx.measureText(txt);
	var v1 = new Vector(x1,y1);
	var v2 = new Vector(x2,y2);
	var offset = (new Vector()).fromAngLen(angle,Math.max(10,Math.abs(dist),metric.width/2*Math.cos(angle)+5)*dist/Math.abs(dist));
	var va = v1.copy().add(offset);
	var dimlen = (new Vector()).fromAngLen(angle+Math.PI/2,1).dot(v2.copy().minus(v1))
	var vb = va.copy().add((new Vector()).fromAngLen(angle+Math.PI/2,1).scalar(dimlen));
	var vt = va.copy().add(vb).scalar(0.5);

	if(va.copy().minus(vb).len<30){
		offset = (new Vector()).fromAngLen(angle, Math.max(10, Math.abs(dist))*dist/Math.abs(dist));
		va = v1.copy().add(offset);
		dimlen = (new Vector()).fromAngLen(angle+Math.PI/2,1).dot(v2.copy().minus(v1))
		vb = va.copy().add((new Vector()).fromAngLen(angle+Math.PI/2,1).scalar(dimlen));
		vt = va.copy().add(vb).scalar(0.5).add(offset.unit().scalar(metric.width/2+5));
	}

	var angAtoB = vb.copy().minus(va).ang;
	ctx.lineWidth = 1;
	ctx.strokeStyle = "#555555";
	ctx.fillStyle = "#555555";
	// Draw line bodies
	ctx.beginPath();
		var vc = va.copy().minus(v1).unit().scalar(4).add(v1);
		var vd = va.copy().minus(v1).unit().scalar(4).add(va);
		ctx.moveTo(vc.x,vc.y);
		ctx.lineTo(vd.x,vd.y);
		//ctx.sharpLineV(vc,vd,0,0,0,255);
		var vc = vb.copy().minus(v2).unit().scalar(4).add(v2);
		var vd = vb.copy().minus(v2).unit().scalar(4).add(vb);
		ctx.moveTo(vc.x,vc.y);
		ctx.lineTo(vd.x,vd.y);
		//ctx.sharpLineV(vc,vd,0,0,0,255);
		ctx.moveTo(va.x,va.y);
		ctx.lineTo(vb.x,vb.y);
		//ctx.sharpLineV(va,vb,0,0,0,255);
	ctx.stroke();
	// Arrowhead A
	ctx.save()
		ctx.translate(va.x,va.y);
		ctx.rotate(angAtoB-Math.PI/2);
		ctx.beginPath();
		ctx.moveTo(0,0);
		ctx.lineTo(2,5);
		ctx.lineTo(-2,5);
		ctx.fill();
		//ctx.sharpLine(0,0,2,5,0,0,0,255);
		//ctx.sharpLine(0,0,-2,5,0,0,0,255);
	ctx.restore();
	// Arrowhead B
	ctx.save()
		ctx.translate(vb.x, vb.y);
		ctx.rotate(angAtoB+Math.PI/2);
		ctx.moveTo(0,0);
		ctx.lineTo(2,5);
		ctx.lineTo(-2,5);
		//ctx.sharpLine(0,0,2,5,0,0,0,255);
		//ctx.sharpLine(0,0,-2,5,0,0,0,255);
		ctx.fill();
	ctx.restore();
	// Draw text
	ctx.fillStyle = "#000000";
	ctx.clearRect(vt.x-metric.width/2-3,vt.y-fontpx/2-1,metric.width+6,fontpx+4);
	ctx.fillText(txt,vt.x,vt.y);
	ctx.restore();
}



// #########		 Crawling:.\Beam.js		#########
"use strict";

function Beam(){

	this.create = function(){
		// #########################################################
		// Misc considerations
		this.eclass 			= "A";
		this.minbarspacing		= undefined;
		// #########################################################
		// Reinforcement considerations
		this.reo = [
			{number:2, diameter:10, area:156, depth:25+10+10/2		},
			{number:2, diameter:10, area:200, depth:600-25-10-10/2	},
		];
		this.df		= 10;
		// #########################################################
		// Geometric considerations
		this.b		= 300;
		this.D		= 600;
		this.cover	= 25;
		this.Ln		= 3000;
		// #########################################################
		// Material considerations
		this.fc		= 32;
		this.Ec		= undefined;
		this.epsiloncmax = 0.003;// TODO: getcorrect code ref. AS3600 8.1.3??
		this.rhoc	= 2400;
		// AS4671 500MPa Steel && AS3600
		this.fsy = 500;// Steel characteristic yield stress: MPa
		// AS3600 3.2.2 taken to be (or determined by test)
		// TODO: add Es to variable inputs (commit with35mins)
		this.Es = 200000;// Steel Young's modulus of elasticity: MPa
		this.epsilonsy = this.fsy/this.Es; // 0.0025 or there-abouts
	}.bind(this);
	// #############################################################################
	// ### CODE COMPLIANCE CHECKERS HELPER FUNCTIONS ###############################
	// #############################################################################	
	// TODO: is_deep_beam ?
	// #############################################################################
	// ### SERVICEABILITY LIMITS ###################################################
	// #############################################################################	
	// TODO:
	// #############################################################################
	// ### GEOMETRIC HELPER FUNCTIONS ##############################################
	// #############################################################################

	Object.defineProperty(this,"innerWidth",{

		get:function innerWidth(){
			return this.b - 2*(this.cover+this.df);
		}.bind(this)}

	);

	this.get_tension_reo = function(){
		console.warn("check this function before use")
		var result = [];
		var dn = this.dn ;

		for(var i = 0; i < this.reo.length;i++){

			if(this.layer_strain_from_layer_dn(this.reo[i], dn)>0){
				result.push(this.reo[i]);
			}

		}

		return result;
	}.bind(this);

	this.get_compression_reo = function(){
		console.warn("check this function before use")
		var result = [];
		var dn = this.dn ;

		for(var i = 0; i < this.reo.length;i++){

			if(this.layer_strain_from_layer_dn(this.reo[i], dn)<0){
				result.push(this.reo[i]);
			}

		}

		return result;
	}.bind(this);
	// #############################################################################
	// ### HIGH LEVEL CAPACITY FUNCTIONS ###########################################
	// #############################################################################

	Object.defineProperty(this,"Muo",{

		get:function Muo(){
			var dn		= this.dn;
			var cc		= this.Cc_from_dn(dn);
			var ccd		= this.Cc_centroid_depth_from_dn(dn);
			var ts		= this.Ts_from_dn(dn);
			var tsd		= this.Ts_centroid_depth_from_dn(dn);
			var cs		= this.Cs_from_dn(dn);
			var csd		= this.Cs_centroid_depth_from_dn(dn);
			return (cc*ccd + ts*tsd + (cs*csd || 0)) / 1000; //kNm
		}.bind(this)}

	);
	// AS3600 8.1.6.1(1)

	Object.defineProperty(this,"Muo_min",{

		get:function(){
			// no prestress only.
			return 1.2*this.Ze*this.fctf/1000000; //mm^3*MPa => Nmm /1000/1000 => kNm
		}.bind(this)}

	);
	// AS3600 8.1.6.1(2)

	Object.defineProperty(this,"Muo_min_Ast_min",{

		get:function(){
			// rect sections only
			// TODO: fix this probalem:
			//console.warn("Check this function before use. 'd' may be wrong here. Using Ts_centroid_depth instead");
			return 0.2*Math.pow(  this.D/this.Ts_centroid_depth   ,2)*this.fctf/this.fsy*this.b*this.Ts_centroid_depth;
		}.bind(this)}

	);
	// TODO: create a proper getter for d, ku and kuo

	Object.defineProperty(this,"dn",{

		get:function(){
			// TODO: make a beam flag to determine whether compression steel is considered in this calculation.
			// TODO: make a check to see that reo that is too small is never fed into this beam calculator
			var dn;
			var top = this.D;
			var bot = 0;
			var diff;
			var cnt = 0;

			do{
				dn = (top+bot)/2;
				diff = this.Ts_from_dn(dn)+this.Cs_from_dn(dn)+this.Cc_from_dn(dn);

				if(diff>0){
					bot = dn;

				}else{
					top = dn;
				}

				cnt++
			}while(Math.abs(diff) > 0.0001 && cnt<20);
			return dn;
		}.bind(this)
	});
	// #############################################################################
	// ### GET TOTAL FORCES ########################################################
	// #############################################################################

	Object.defineProperty(this,"Ts",{get:function(){
		return this.Ts_from_dn(this.dn);
	}.bind(this)});

	Object.defineProperty(this,"Cs",{get:function(){
		return this.Cs_from_dn(this.dn);
	}.bind(this)});

	Object.defineProperty(this,"Cc",{get:function(){
		return this.Cc_from_dn(this.dn);
	}.bind(this)});

	this.Ts_from_dn = function(dn){
		return this.Fs_from_dn_tension(dn,true);
	}.bind(this);

	this.Cs_from_dn = function(dn){
		return this.Fs_from_dn_tension(dn,false);
	}.bind(this);

	this.Cc_from_dn = function(dn){
		return -(this.b*dn*this.gamma) * (this.fc*this.alpha2)/1000; // kN
	}.bind(this);

	this.Fs_from_dn_tension = function(dn, returntension){
		var result = 0;
		var epsilonsi;

		for(var i = 0;i<this.reo.length;i++){
			// First get strain in the steel layer according to similar triangles:
			epsilonsi = this.epsiloncmax/dn*(this.reo[i].depth - dn);
			// Limit the strain to a range of -0.0025 to 0.0025

			if(returntension){
				epsilonsi = Math.max(0, Math.min(epsilonsi, this.epsilonsy));

			}else{
				epsilonsi = Math.max(-this.epsilonsy, Math.min(epsilonsi, 0));
			}

			result += this.reo[i].area * this.Es * epsilonsi/1000; // kN
		}

		return result;
	}.bind(this);
	// #############################################################################
	// ### GET FORCE CENTROIDS #####################################################
	// #############################################################################
	// TODO: Which layers of steel should be disregarded? Surely steel 'close' to the centroid should be left out.

	Object.defineProperty(this,"Ts_centroid_depth",{get:function(){
		return this.Ts_centroid_depth_from_dn(this.dn);
	}.bind(this)});

	Object.defineProperty(this,"Cs_centroid_depth",{get:function(){
		return this.Cs_centroid_depth_from_dn(this.dn);
	}.bind(this)});

	Object.defineProperty(this,"Cc_centroid_depth",{get:function(){
		return this.Cc_centroid_depth_from_dn(this.dn)
	}.bind(this)});

	this.Ts_centroid_depth_from_dn = function(dn){
		return this.Fs_centroid_from_dn_tension(dn, true);
	}.bind(this);

	this.Cs_centroid_depth_from_dn = function(dn){
		return this.Fs_centroid_from_dn_tension(dn, false);
	}.bind(this);

	this.Cc_centroid_depth_from_dn = function(dn){
		return this.gamma * dn / 2;
	}.bind(this);

	this.Fs_centroid_from_dn_tension = function(dn, returntension){
		var epsilonsi;
		var sum_area = 0;
		var sum_area_times_depth = 0;

		for(var i = 0;i<this.reo.length;i++){
			// First get strain in the steel layer according to similar triangles:
			epsilonsi = this.epsiloncmax/dn*(this.reo[i].depth - dn);
			// Then depending on if we are looking for tension or compression steel, get weighted average depth

			if(  (returntension && epsilonsi>0)  ||  (!returntension && epsilonsi<0)  ){
				sum_area += this.reo[i].area;
				sum_area_times_depth += this.reo[i].area * this.reo[i].depth;
			}

		}

		return sum_area_times_depth/sum_area || undefined;
	}.bind(this);
	// #############################################################################
	// ### GET INDIVIDUAL STEEL FORCES #############################################
	// #############################################################################

	this.layer_strain_from_layer_dn = function(layer,dn){
		// First get strain in the steel layer according to similar triangles:
		var epsilonsi = this.epsiloncmax/dn*(layer.depth - dn);
		// Limit the strain to a range of -0.0025 to 0.0025
		// (The stress does not increase after yielding at fsy)
		epsilonsi = Math.max(-this.epsilonsy, Math.min(epsilonsi, this.epsilonsy));
		return epsilonsi
	}.bind(this);

	this.layer_force_from_layer_dn = function(layer,dn){
		var layer_strain = this.layer_strain_from_layer_dn(layer,dn);
		return layer.area * this.Es * layer_strain/1000; // kN
	}.bind(this);

	this.layer_yielded_from_layer_dn = function(layer,dn){
		var layer_strain = this.layer_strain_from_layer_dn(layer, dn);
		return layer_strain<=-0.0025 || layer_strain>=0.0025;
	}.bind(this);
	// #############################################################################
	// ### GET STEEL AREAS #########################################################
	// #############################################################################

	Object.defineProperty(this,"Ast",{get:function(){
		return this.Ast_from_dn(this.dn);
	}.bind(this)});

	Object.defineProperty(this,"Asc",{get:function(){
		return this.Asc_from_dn(this.dn);
	}.bind(this)});

	Object.defineProperty(this,"Acc",{get:function(){
		return this.gamma*this.dn*this.b;
	}.bind(this)});

	this.Ast_from_dn = function(dn){
		return this.As_from_dn_tension(dn,true);
	}.bind(this);

	this.Asc_from_dn = function(dn){
		return this.As_from_dn_tension(dn,false);
	}.bind(this);

	this.As_from_dn_tension = function(dn, returntension){
		var epsilonsi;
		var sum_area = 0;

		for(var i = 0;i<this.reo.length;i++){
			// First get strain in the steel layer according to similar triangles:
			epsilonsi = this.epsiloncmax/dn*(this.reo[i].depth - dn);
			// Then depending on if we are looking for tension or compression steel, get weighted average depth

			if(  (returntension && epsilonsi>0)  ||  (!returntension && epsilonsi<0)  ){
				sum_area += this.reo[i].area;
			}

		}

		return sum_area || undefined;
	}.bind(this);
	// ########################################################################
	// #### MISC COEFICIENTS ##################################################
	// ########################################################################

	Object.defineProperty(this,"gamma",{get:function(){
		var r1 = 1.05-this.fc*0.007;
		var r2 = Math.max(0.67,Math.min(0.85,r1)) 
		return r2;
	}.bind(this)});

	Object.defineProperty(this,"alpha2",{get:function(){
		var r1 = 1-this.fc*0.003
		var r2 = Math.max(0.67,Math.min(0.85,r1));
		return r2;
	}.bind(this)});
	// TODO: note that this is only when no better info is avaliable.
	// TODO: sort

	Object.defineProperty(this,"fctf",{get:function(){
		return 0.6*Math.sqrt(this.fc);
	}.bind(this)});
	// ########################################################################
	// #### SECTION PROPERTIES ################################################
	// ########################################################################

	Object.defineProperty(this,"Ze",{get:function(){
		// Rectangular section only
		return this.b*Math.pow(this.D,2)/6;
	}.bind(this)});

	Object.defineProperty(this,"Ixx",{get:function(){
		// Rectangular section only
		return this.b*Math.pow(this.D,3)/12;
	}.bind(this)});
	// STARTOFF: 4:35 14 04 14

	this.toString = function(){
		return JSON.stringify(this).replace(/,/g,",\n");
	}.bind(this);

	Object.defineProperty(this,"Ag",{get:function(){
		// Rectangular section only
		return this.b*this.D;
	}.bind(this)});
	// TODO: sort
	// Reo ratio

	Object.defineProperty(this,"p",{get:function(){
		// rect section only
		return this.Ast/this.b/this.D;
	}.bind(this)});
	// AS3600 8.5.3.1

	Object.defineProperty(this,"beta",{get:function(){
		// rect section only
		return this.Ast/this.b/this.D;
	}.bind(this)});
	this.create();
	/*
	*/
};



// #########		 Crawling:.\varinput.js		#########



// #########		 Crawling:.\EventDispatcher.js		#########
/**
 * This mixin is used to lend primative event management to another class. The maintenance of this class is important!
 * @class EventDispatcher
 * @example
 * 	var ev = new EventDispatcher();

 * 	ev.on("run",function(e){
 * 		console.log(e);
 * 	});
 */

function EventDispatcher() {
	"use strict";
 /**
	 * This is set automotically when the mixin is instantiated. It is used to prevent repeated instantiation.
	 * @property isEventDispatcher
	 * @private
	 */

	if(this.__isEventDispatcher == true){
		return;
	}

	this.__isEventDispatcher = true;
	/**
	 * Used as an internal dictionary to relate event names to event functions.
	 * @property events
	 * @type {Object}

	 */
	this.__events = {};
	/**
	 * @method on
	 * @param EventName {String}

	 * @param ListenerFunction {String}

	 */

	this.on = (function (eventName, eventFunction) {

		if (typeof eventName !== "string" || typeof eventFunction !== "function") {
			console.log("Invalid event registration, " + eventName);
			return;
		}


		if (this.__events[eventName] === undefined) {
			this.__events[eventName] = [];
		}

		this.__events[eventName].push(eventFunction);
	}).bind(this);
	/**
	 * @method clearListeners
	 * @param EventName {String}

	 */

	this.clearListeners = (function (eventName) {

		if (this.__events[eventName] !== undefined) {
			this.__events[eventName] = [];
		}

	}).bind(this);
	/**
	 * If the event name is unknown, this method will fail quietly, like a fish.
	 * @method dispatch
	 * @param EventName {String}

	 * @param EventData {Any}

	 */

	this.dispatch = function (eventName, eventData) {

		if (this.__events[eventName] !== undefined) {

			for (var i = 0; i < this.__events[eventName].length; i++) {
				this.__events[eventName][i](eventData);
			}


		} else {
			//fail quietly, like a fish.
		}

	}.bind(this);
}

function VarInput(arg_id,arg_notation,arg_type,arg_value,arg_unit,arg_href,arg_target,arg_options){
	EventDispatcher.call(this);
	this._options = arg_options;
	this._notation = "";
	this._type = arg_type;
	this.validate = function(v){return v;};
	// ##########################################################################################
	// 			BUILD INTERFACE
	// ##########################################################################################

	this.buildInterface = function(){
		this.body = document.createElement("table");
		this.row = document.createElement("tr");
		this.body.className = "varinput";
		this.notationDiv = document.createElement("td");
		this.notationDiv.className = "notation-div";
		this.valueDiv = document.createElement("td");
		this.valueDiv.className = "value-div";
		this.unitDiv = document.createElement("td");
		this.unitDiv.className = "unit-div";
		this.notationAnchor = document.createElement("a");

		if(arg_options){
			this.valueInput	= document.createElement("select");
			this.options 		= arg_options;

		}else if(arg_type == "number"){
			this.valueInput		= document.createElement("input");
			this.valueInput.type = "number";

		}else if(arg_type == "text"){
			this.valueInput		= document.createElement("input");
			this.valueInput.type = "text";

		}else{
			this.valueInput		= document.createElement("input");
			this.valueInput.type = "none";
			this.valueInput.readonly=true;
		}

		this.valueDiv.appendChild(this.valueInput);
		this.notationDiv.appendChild(this.notationAnchor);
		this.row.appendChild(this.notationDiv);
		this.row.appendChild(this.valueDiv);
		this.row.appendChild(this.unitDiv);
		this.body.appendChild(this.row);
		this.notation	= arg_notation;
		this.href		= arg_href;
		this.target		= arg_target;
		this.id		= arg_id
		this.unit	= arg_unit;
		this.value	= arg_value;
		this.notationAnchor.tabIndex=-1;
	}.bind(this);
	// ##########################################################################################
	// 			EVENT LISTENERS
	// ##########################################################################################

	this.configureEvents = function(){

		this.valueInput.addEventListener("change",function(e){
			var val = {value:this.value, error:[], warning:[], info:[]};
			val = this.validate(val);
			this.value = val.value;

			if(val.error.length>0){
				this.valueInput.setCustomValidity("NO")
			}

			this.update();
			this.change();
		}.bind(this));

		this.valueInput.addEventListener("input",function(e){
			var val = {value:this.value, error:[], warning:[], info:[]};
			val = this.validate(val);

			if(val.error.length>0){
				this.valueInput.setCustomValidity("NO")
			}

			this.update();
			this.change();
		}.bind(this));

		this.body.addEventListener("click", function(e){

			if(e.target.tagName!=="INPUT" && e.target.tagName!=="SELECT"){
				//e.preventDefault();
				this.notationAnchor.click();

				if(this.valueInput.tagName == "SELECT"){
					this.valueInput.focus();

				}else{
					this.valueInput.select();
				}

			}

			this.update();
			this.change();
		}.bind(this))
	}.bind(this);

	this.update = function(){
		this.dispatch("update",this);
	}.bind(this);

	this.change = function(){
		this.dispatch("change",this);
	}.bind(this);
	// ##########################################################################################
	// 			HELPER FUNCTIONS
	// ##########################################################################################

	this.appendTo = function(dom){
		dom.appendChild(this.body)
		this.updateMathJax();
		this.configureEvents();
	}.bind(this);

	this.updateMathJax = function(){

		if(document.body.contains(this.body)){

			try{
				MathJax.Hub.Queue(["Typeset",MathJax.Hub,this.body]);

			}catch(e){
				this.notation = this.id;
				// Fail gracefully sort of
			}

		}

	}.bind(this);
	// ##########################################################################################
	// 			GETTERS AND SETTERS
	// ##########################################################################################

	Object.defineProperty(this,"notation",{

		get:function(){
			this._notation;
		}.bind(this),

		set:function(newval){
			this.notationAnchor.innerHTML	= newval;
			this.updateMathJax();
		}.bind(this)
	});

	Object.defineProperty(this,"target",{

		get:function(){
			this.notationAnchor.target;
		}.bind(this),

		set:function(newval){
			this.notationAnchor.target	= newval;
		}.bind(this)
	});

	Object.defineProperty(this,"href",{

		get:function(){
			this.notationAnchor.href;
		}.bind(this),

		set:function(newval){
			this.notationAnchor.href	= newval;
		}.bind(this)
	});

	Object.defineProperty(this,"value",{

		get:function(){

			if(this._type == "number"){
				return parseInt(this.valueInput.value);
			}

			return this.valueInput.value;
		}.bind(this),

		set:function(newval){
			this.valueInput.value = newval;
		}.bind(this)
	});

	Object.defineProperty(this,"options",{

		get:function(){
			return this._options;
		}.bind(this),

		set:function(newval){
			this._options = newval;

			for(var i=0;i<this._options.length;i++){
				var o = document.createElement("option");
				o.innerHTML = this._options[i];
				this.valueInput.appendChild(o);
			}

		}.bind(this),
	});

	Object.defineProperty(this,"unit",{

		get:function(){
			this.unitDiv.innerHTML;
		}.bind(this),

		set:function(newval){
			this.unitDiv.innerHTML = newval;
		}.bind(this)
	});
	this.buildInterface();
}




// #########		 Crawling:.\setup_varinputs.js		#########
var vin = {};
vin.Ln     = new VarInput('Ln' , "$$$L_n$$$" , "number" , 4000, "mm", "infos/Ln.htm", "varinfoiframe");
vin.b      = new VarInput('b' , "$$$b$$$" , "number" , 300, "mm", "infos/b.htm", "varinfoiframe");
vin.D      = new VarInput('D' , "$$$D$$$" , "number" , 600, "mm", "infos/D.htm", "varinfoiframe");
vin.cover  = new VarInput('cover' , "$$$\\text{Cover}$$$" , "number" , 25, "mm", "infos/cover.htm", "varinfoiframe");
vin.eclass = new VarInput('eclass' , "$$$\\text{E. Class}$$$" , "text" , "A1", "", "infos/eclass.htm", "varinfoiframe",["A1","A2","B1","B2","C1","C2"]);
vin.df     = new VarInput('df' , "$$$d_f$$$" , "number" , 10, "mm", "infos/df.htm", "varinfoiframe",[10, 12, 16, 20, 24, 28, 32, 36, 40]);
vin.rhoc   = new VarInput('rhoc', "$$$\\rho_c$$$" , "number" , 2400, "kg/m&#179;", "infos/rhoc.htm", "varinfoiframe");
vin.fc     = new VarInput('fc' , "$$$f_c$$$" , "number" , 32, "MPa", "infos/fc.htm", "varinfoiframe",[20, 25, 32, 40, 50, 65, 80, 100]);
vin.Ln

vin.b.validate = function(e){
	//var e = {value:this.value, error:[], warning:[], info:[]};

	if(e.value%5!==0){
		e.error.push("b should be a rounded to the nearest 5mm");
	}


	if(e.value<100){
		e.value=100;
	}


	if(e.value>3000){
		e.value=3000;
	}

	return e;
}




// #########		 Crawling:.\validation.js		#########

function DoValidation(){
	return
	var error_list = []
	var warning_list = []
	var Ln = document.getElementById("Ln");
	var D = document.getElementById("D");
	var b = document.getElementById("b");
	var cover = document.getElementById("cover");
	var eclass = document.getElementById("eclass");
	var fc = document.getElementById("fc");
	Ln.setCustomValidity("");
	D.setCustomValidity("");
	b.setCustomValidity("");
	cover.setCustomValidity("");
	eclass.setCustomValidity("");
	fc.setCustomValidity("");
	/** Ln
				too short
				too long
				span/depth ratio
	**/

	if(Ln.integerValue<500){
		error_list.push("Ln<500mm. This is too short to be considered a beam.");
		Ln.setCustomValidity("Ln too short.");

	}else if(Ln.integerValue<1000){
		warning_list.push("Ln<1000mm. This may be a bit short for the type of analysis used in this software.");
		//Ln.setCustomValidity("Ln too short.");

	}else if(Ln.integerValue>15000 && Ln.integerValue<25000){
		warning_list.push("Ln>15m. This is pretty long for a clear-span. Consider some columns!");
		//Ln.setCustomValidity("Ln too long.");

	}else if(Ln.integerValue>=25000){
		error_list.push("Ln>25m. This is too long for a clear-span. Columns would be needed.");
		Ln.setCustomValidity("Ln too long.");
	}

	// AS3600 8.5 - deflection span to depth ratio limits
	// TODO: confirm these values
	var span_to_depth = (Ln.integerValue/D.integerValue);

	if(span_to_depth>10){
		error_list.push("Ln/D =  "+span_to_depth.toFixed(1)+" (>10) This is a very small span to depth ratio. D should be more than "+(Math.ceil(Ln.integerValue/10/10)*10).toFixed(0)+"mm");
		Ln.setCustomValidity("Ln/D too small.");
		D.setCustomValidity("Ln/D too small.");

	}else if(span_to_depth<0.25 && Ln.integerValue!==0){
		error_list.push("Ln/D =  "+span_to_depth.toFixed(2)+" (< 0.25) This is a very low span on depth ratio. D should be less than "+(Math.ceil(Ln.integerValue/0.25/10)*10).toFixed(0)+"mm This software does not support 'deep' beams [See AS3600 Section 12 - Non Fexural members]");
		Ln.setCustomValidity("Ln/D too high.");
		D.setCustomValidity("Ln/D too high.");
	}

	/** b
				minimum: 200 - arbitrary
				maxumum: 5000 - arbitrary
				underasonably large: 1500??
				breadth/depth ratio: ?? slab vs deep beam
				reasonabled multiple
	**/
	// TODO: confirm these values of bread/depth
	var breadth_on_depth = b.integerValue/D.integerValue;

	if(breadth_on_depth>5 && D.integerValue<300){
		error_list.push("b/D =  "+breadth_on_depth.toFixed(1)+" (> 5) This looks more like a slab than a beam. This software does not support slabs. [See AS3600 Section 9]");
		b.setCustomValidity("b/D looks like slab.");
		D.setCustomValidity("b/D looks like slab.");
	}

	// TODO: verify this bs

	if(breadth_on_depth<0.2){
		error_list.push("b/D =  "+breadth_on_depth.toFixed(1)+" (< 0.2) This looks more like a wall than a beam. The b should be greater than "+(Math.ceil(0.2*D.integerValue/10)*10).toFixed(0));
		b.setCustomValidity("b/D looks like slab.");
		D.setCustomValidity("b/D looks like slab.");
	}


	if(b.integerValue<200){
		error_list.push("b<200mm. This is not wide enough to be a beam.");
		b.setCustomValidity("Not wide enough");

	}else if(b.integerValue>1500 && b.integerValue<3000){
		warning_list.push("b>1500mm. This is probably a bit too wide for a beam.");

	}else if(b.integerValue>=2500){
		error_list.push("b>3000mm. This is too wide to be designed as a normal beam.");
		b.setCustomValidity("Too wide");
	}


	if(b.integerValue%5!==0){
		warning_list.push("b should be rounded to the nearest 5mm. Construction tollerances are not milimeter accurate.");
	}

	/** D
				minimum: 200 - arbitrary
				maxumum: 3000 - arbitrary
				reasonabled multiple
				underasonably large: 2000??
				deep beam limitation: ??
				breadth/depth ratio: (see above)
				span/depth ratio:	(see above)
	**/
	// TODO: check the

	if(D.integerValue<200){
		error_list.push("D<200mm. This is too shallow for a beam.");
		D.setCustomValidity("Too shallow");

	}else if(D.integerValue<300){
		warning_list.push("D<300mm. This is probably a bit shallow for a beam.");

	}else if(D.integerValue>2000 && D.integerValue<3000){
		warning_list.push("D>2000mm. This is probably a bit too deep for a beam.");

	}else if(D.integerValue>=3000){
		error_list.push("D>3000mm. This is too deep to be designed as a normal beam.");
		D.setCustomValidity("Too deep");
	}


	if(D.integerValue%5!==0){
		warning_list.push("D should be rounded to the nearest 5mm.  Construction tollerances are not milimeter accurate.");
	}

	/** cover
				match with eclass 4.10.3.2
				resonable multiple
				not too big ?? how big is too big?
				not too small
	**/

	if(cover.integerValue<25){

	}if(cover.integerValue<25){
	}


	if(cover.integerValue%5!==0){
		warning_list.push("Cover should be rounded to the nearest 5mm.  Construction tollerances are not milimeter accurate.");
	}

	/** eclass
				match with cover fromt able
				chosen from list
				matches f'c accroding to Table 4.4
	**/
	var class_index = [
		"A1",
		"A2",
		"B1",
		"B2",
		"C1",
		"C2"
	];
	var fc_index = 	[20,25,32,40,50];
	var coverdata_standard = [ // AS3600+A2 T4.10.3.2
		[20,20,20,20,20],
		[  ,30,25,20,20],
		[  ,  ,40,30,25],
		[  ,  ,  ,45,35],
		[  ,  ,  ,  ,50],
		[  ,  ,  ,  ,65]
	];
	var coverdata_nonstandard = [ // AS3600+A2 T4.10.3.3
		[20,20,20,20,20],
		[  ,30,20,20,20],
		[  ,  ,30,25,20],
		[  ,  ,  ,35,25],
		[  ,  ,  ,  ,45],
		[  ,  ,  ,  ,60]
	];
	// find standard cover requirement:

	for(var fc_index_i=0;fc_index_i<fc_index.length-1;fc_index_i++){

		if(fc.integerValue>=fc_index[fc_index_i] && fc.integerValue<fc_index[fc_index_i+1]){
			break;
		}

	}

	var standard_min_cover 		= coverdata_standard[class_index.indexOf(eclass.textValue)][fc_index_i];
	var nonstandard_min_cover	= coverdata_nonstandard[class_index.indexOf(eclass.textValue)][fc_index_i];

	if(standard_min_cover === undefined){
		requed_fc = fc_index_i;

		while(coverdata_standard[class_index.indexOf(eclass.textValue)][requed_fc] === undefined){
			requed_fc++;
		}

		error_list.push("f'c insufficient for Exposure classification without special considerations. Increase f'c to "+fc_index[requed_fc]+"MPa. See AS3600 Table 4.10.3.2 and Table 4.10.3.3");
		fc.setCustomValidity("Mismatch with eclass.");
		eclass.setCustomValidity("Mismatch with cover.");

	}else	if(cover.integerValue<standard_min_cover){
		error_list.push("Cover insufficient for f'c and Exposure classification without special considerations. Increase cover to "+standard_min_cover+"mm. See AS3600 Table 4.10.3.2 and Table 4.10.3.3");
		// TODO: or increase f_c to ^^
		cover.setCustomValidity("Insufficint for fc and eclass");
		eclass.setCustomValidity("Mismatch with cover.");
	}

	// TODO: more and less buttons still dont work.
	// Slab recognition doesnt really work too well.
	/** df
				chosen from list
	**/
	/** rhoc
				resonable multiple
				within perscribed range
	**/
	/** REO
				second row of reo on wide shallow beams is stupid
	**/
	var ebar = document.querySelector("#invardiverrorbar");
	ebar.innerHTML = "";

	if(error_list.length>0){
		ebar.innerHTML += '<ul class="errorlist"><li>'+error_list.join("</li><li>")+'</li></ul>';
	}


	if(warning_list.length>0){
		ebar.innerHTML += '<ul class="warninglist"><li>'+warning_list.join("</li><li>")+'</li></ul>';
	}

}



// #########		 Crawling:.\reoinput.js		#########

function ReoInput(){
	EventDispatcher.call(this);
	this.diameters	= [10,	12,		16,		20,		24,		28,		32,		36,		40];
	this.areas		= [78,	113,	201,	314,	452,	616,	804,	1020,	1260];
	this.masses		= [0.632,0.910,1.619,2.528,3.640,4.955,6.471,8.910,10.112];

	this.create = function(){
		this.body = document.createElement("tr");
		this.body.className = "reoinput";
		this.body.innerHTML = 
		'<td><input type="checkbox" class="enabled"></td>\
		<td><input class="barcode" required value="2N10"\></td>\
		<td><button class="more" tabindex="-1">+</button><button class="less" tabindex="-1">-</button></td>\
		<td class="area">--</td>\
		<td><input type="number" class="offset" value="0" required/></td>\
		<td><select class="from"><option>lowest</option><option>highest</option></select></td>\
		<td><input type="checkbox" class="selected"/></td>';
		this.enabledCheckbox = this.body.querySelector(".enabled");
		this.barcodeInput = this.body.querySelector(".barcode");
		this.moreButton = this.body.querySelector(".more");
		this.lessButton = this.body.querySelector(".less");
		this.areaOutput = this.body.querySelector(".area");
		this.offsetInput = this.body.querySelector(".offset");
		this.fromInput = this.body.querySelector(".from");
		this.selectedCheckbox = this.body.querySelector(".selected");
		this.enabled = false;
	}.bind(this);
	// ##########################################################################################
	// 			BIND EVENTS
	// ##########################################################################################

	this.appendTo = function(dom){
		dom.appendChild(this.body);

		this.enabledCheckbox.addEventListener("change",function(e){
			this.enabled = this.enabledCheckbox.checked;
			this.change();
		}.bind(this));

		this.selectedCheckbox.addEventListener("change",function(e){
			this.selected = this.selectedCheckbox.checked;
			this.change();
		}.bind(this));

		this.moreButton.addEventListener("click",function(){
			this.more();
			this.update();
			this.change();
		}.bind(this));

		this.lessButton.addEventListener("click",function(){
			this.less();
			this.update();
			this.change();
		}.bind(this));
		// BARCODE CHANGE EVENT LISTENERs

		this.barcodeInput.addEventListener("keydown",function(e){
			if(e.keyCode == 38){	// up button
				this.more();
				e.preventDefault();
				this.update();
				this.change();
			}

			if(e.keyCode == 40){	// down button
				this.less();
				e.preventDefault();
				this.update();
				this.change();
			}

		}.bind(this))

		this.barcodeInput.addEventListener("change",function(){
			this.update();
			this.change();
		}.bind(this));

		this.barcodeInput.addEventListener("input",function(e){
			var val = e.target.value;
			var ss = e.target.selectionStart;
			var se = e.target.selectionEnd;
			var arr = val.split("")
			var flag = false;
			var noN = true;

			for(var i=0;i<arr.length;i++){

				if((/[^0-9nN]/).test(arr[i])){
					arr.splice(i--,1);
					;

					if(i<ss){
						ss--;
						se=ss;
					}

				}


				if(arr[i]=="N"){
					noN = false;
				}

			}

			val = arr.join("");
			val = val.toUpperCase();
			e.target.value =  val;
			e.target.setSelectionRange(ss,se);
			this.update();
			this.change();
		}.bind(this))
	}.bind(this);
	// ##########################################################################################
	// 			GETTER/SETTERS
	// ##########################################################################################
	//				GET/SET ENABLED

	Object.defineProperty(this,"enabled",{

		get:function(){
			return this.enabledCheckbox.checked;
		}.bind(this),

		set:function(newval){
			this.enabledCheckbox.checked = newval;

			if(newval == true){
				this.body.style.color = "";

			}else if(newval == false){
				this.body.style.color = "grey";
				this.selected = false;
			}

			this.barcodeInput.disabled		= !newval;
			this.moreButton.disabled		= !newval;
			this.lessButton.disabled		= !newval;
			this.areaOutput.disabled		= !newval;
			this.offsetInput.disabled		= !newval;
			this.fromInput.disabled			= !newval;
			this.selectedCheckbox.disabled= !newval;
			this.update();
		}.bind(this),
	});
	//				GET/SET SELECTED

	Object.defineProperty(this,"selected",{

		get:function(){
			return this.selectedCheckbox.checked;
		}.bind(this),

		set:function(newval){
			this.selectedCheckbox.checked = newval;
			this.update();
		}.bind(this),
	});
	// 			GET/SET barcode

	Object.defineProperty(this,"barcode",{

		get:function(){
			return this.barcodeInput.value;
		}.bind(this),

		set:function(newval){
			this.barcodeInput.value = newval;
			this.update();
		}.bind(this),
	});
	// 			GET/SET area

	Object.defineProperty(this,"area",{

		get:function(){
			return this.areas[this.diameters.indexOf(this.diameter)]*this.number || undefined;
		}.bind(this)
	});
	// 			GET/SET mass_per_meter

	Object.defineProperty(this,"mass_per_meter",{

		get:function(){
			return this.masses[this.diameters.indexOf(this.diameter)]*this.number || undefined;
		}.bind(this)
	});
	// 			GET/SET diameter

	Object.defineProperty(this,"diameter",{

		get:function(){
			return parseInt(this.barcode.split("N")[1]) || undefined;
		}.bind(this),

		set:function(newval){

			if(this.diameters.indexOf(newval)!==-1){
				this.barcode = this.number + "N" + newval;

			}else{
				console.warn("Invalid assignment to reo-input diameter: "+newval);
			}

		}.bind(this)
	});
	// 			GET/SET number

	Object.defineProperty(this,"number",{

		get:function(){
			return parseInt(this.barcode.split("N")[0]);
		}.bind(this),

		set:function(newval){

			if(typeof newval == "number" && newval!==NaN && newval!==undefined && newval>=2 && newval<100){
				this.barcode = newval + "N" + this.diameter;

			}else{
				console.warn("Invalid assignment to reo-input number: "+newval);
			}

		}.bind(this)
	});
	// 			GET/SET OFFSET

	Object.defineProperty(this,"offset",{

		get:function(){
			return parseInt(this.offsetInput.value);
		}.bind(this),

		set:function(newval){
			this.offsetInput.value = Math.abs(Math.round(parseFloat(newval)));
			this.update();
		}.bind(this),
	});
	// 			GET/SET FROM

	Object.defineProperty(this,"from",{

		get:function(){
			return this.fromInput.value;
		}.bind(this),

		set:function(newval){
			this.fromInput.value = newval;
			this.update();
		}.bind(this),
	});
	// ##########################################################################################
	// 			UPDATE
	// ##########################################################################################

	this.update = function(){
		this.areaOutput.innerHTML = this.area || "--";
		this.dispatch("update",this);
	}.bind(this);

	this.change = function(){
		this.dispatch("change",this);
	}.bind(this);
	// ##########################################################################################
	// 			HELPERS
	// ##########################################################################################

	this.makeFirstRow = function(){
		this.enabled = true;
		this.enabledCheckbox.disabled = true;
		this.offsetInput.disabled = true;
		this.fromInput.disabled = true;
		this.offsetInput.style.visibility = "hidden";
		this.fromInput.style.visibility = "hidden";
	}.bind(this);
	// ##########################################################################################
	// 			MORE AND LESS HELPER FUNCTIONS
	// ##########################################################################################

	this.more = function(){
		var b = parseInt(vin.b.value);
		var D = parseInt(vin.D.value);
		var df = parseInt(vin.df.value);
		var cover = parseInt(vin.cover.value);
		var fitwidth = b-2*cover-2*df;
		var manager = this.manager;
		if(manager.getBottomRow()===this || manager.getTopmostTop()===this){// TODO: or if the row is pressed against the top allow multi bars of comp reo.
			// TODO: assume minimum spacing of 20mm between
			// TODO: assume maximum spacing of 300mm c-c
			// TODO: assume maximum of 10 bars
			this.barcode = this._more_less_barcode(true, 10, 300, 20, fitwidth, this.area) || this.barcode;

		}else{
			// TODO: assume maximum of 2 bars
			this.barcode = this._more_less_barcode(true, 2,  300, 20, fitwidth, this.area) || this.barcode;
		}

	}.bind(this);

	this.less = function(){
		var b = parseInt(vin.b.value);
		var D = parseInt(vin.D.value);
		var df = parseInt(vin.df.value);
		var cover = parseInt(vin.cover.value);
		var fitwidth = b-2*cover-2*df;
		var manager = this.manager;
		if(manager.getBottomRow()===this || manager.getTopmostTop()===this){// TODO: or if the row is pressed against the top allow multi bars of comp reo.
			// TODO: assume minimum spacing of 20mm between
			// TODO: assume maximum spacing of 300mm c-c
			// TODO: assume maximum of 10 bars
			this.barcode = this._more_less_barcode(false, 10, 300, 20, fitwidth, this.area) || this.barcode;

		}else{
			// TODO: assume maximum of 2 bars
			this.barcode = this._more_less_barcode(false, 2,  300, 20, fitwidth, this.area) || this.barcode;
		}

	}.bind(this);

	this._more_less_barcode = function (getmore, maxbar, max_spacing, min_gap, fitwidth, current_area){
		var combs = [];
		var num,dia,diai,minw,maxw;

		for(num = 2; num<=maxbar;num++){

			for(diai=0;diai<this.diameters.length;diai++){
				dia = this.diameters[diai];
				minw = dia*num+(num-1)*min_gap;
				maxw = dia*num+(num-1)*max_spacing;

				if(fitwidth>=minw && fitwidth<=maxw){
					combs.push({number:num, diameter:dia, area:this.areas[diai]*num})
				}

			}

		}


		combs.sort(function(a,b){

			if(getmore){
				return a.area-b.area;

			}else{
				return b.area-a.area;
			}

		})
		//console.table(combs);
		// go through pairwise and remove all adjacent combos within 50mm^2 of eachother where one has less bars than the other
		var da = 0;
		var dn = 0;

		for(var i = 0;i<combs.length-1;i++){
			da = Math.abs(combs[i].area - combs[i+1].area);

			if(da>50){

				if(combs[i].number<combs[i+1].number){
					combs.splice(i+1,1);

				}else if(combs[i].number>combs[i+1].number){
					combs.splice(i,1);
					i--;
				}

			}

		}

		// go through pairwise and remove all adjacent combos within 100mm^2 of eachother if one has less than or equal to half the number of bars.
		var da = 0;
		var dn = 0;

		for(var i = 0;i<combs.length-1;i++){
			da = Math.abs(combs[i].area - combs[i+1].area);

			if(da>50){

				if(combs[i].number<=combs[i+1].number/2){
					combs.splice(i+1,1);

				}else if(combs[i+1].number<=combs[i].number/2){
					combs.splice(i,1);
					i--;
				}

			}

		}

		//console.log(combs.length);

		for(var i = 0;i<combs.length;i++){

			if(getmore){

				if(combs[i].area>current_area){
					return combs[i].number+"N"+combs[i].diameter;
				}


			}else{

				if(combs[i].area<current_area){
					return combs[i].number+"N"+combs[i].diameter;
				}

			}

		}

		// no suitable combination was found. Return the top combination.
		return combs[combs.length-1].number+"N"+combs[combs.length-1].diameter;
	}.bind(this);// end _more_less_barcode
	this.create();
}



// #########		 Crawling:.\ReoManager.js		#########

function ReoManager(arg_body){
	EventDispatcher.call(this);
	this.body = arg_body;
	this.rows = [];

	this.create = function(){
		var firstrow = this.createReoInput();
		firstrow.makeFirstRow();
		this.rows.push(this.createReoInput());
		this.rows.push(this.createReoInput());
		this.rows.push(this.createReoInput());
		this.rows.push(firstrow);

		for(var i = 0;i<this.rows.length;i++){
			this.rows[i].appendTo(this.body);
		}

		this.update();
	}.bind(this);

	this.getEnabledSelectedRows = function(){
		var result = [];

		for(var i = 0;i<this.rows.length;i++){

			if(this.rows[i].enabled && this.rows[i].selected){
				result.push(this.rows[i]);
			}

		}

		return result;
	}.bind(this);

	this.getEnabledRows = function(){
		var result = [];

		for(var i = 0;i<this.rows.length;i++){

			if(this.rows[i].enabled){
				result.push(this.rows[i]);
			}

		}

		return result;
	}.bind(this);

	this.getTopmostTop = function(){
		var r = this.getEnabledRows();

		for(var i = 0;i<r.length;i++){
			// TODO: finish this and swim through the mire that is determining the order and fit of the bars.
			// LEFTOFF: 2014 04 16 23:25

			if(r[i].from==="highest"){

				if(r[i].offset===0){
					return r[i];
				}

				break;
			}

		}

		return undefined;
	}.bind(this);

	this.getBottomRow = function(){
		var r = this.getEnabledRows();
		return r[r.length-1];
	}.bind(this);

	this.getDepthOfRow = function(row){
		var D = parseInt(vin.D.value);
		var df = parseInt(vin.df.value);
		var cover = parseInt(vin.cover.value);
		var rs = this.getEnabledRows();
		var br = this.getBottomRow();
		var last_low_depth = D-cover-df;
		var last_high_depth = cover+df;

		for(var i = rs.length-1;i>=0;i--){

			if(rs[i].from === "lowest"){

				if(rs[i] === row){
					return last_low_depth - rs[i].offset - rs[i].diameter/2;

				}else{
					last_low_depth -= rs[i].offset + rs[i].diameter;
				}

			}

		}


		for(var i = 0; i<rs.length-1; i--){

			if(rs[i].from === "highest"){

				if(rs[i] === row){
					return last_high_depth + rs[i].offset + rs[i].diameter/2;

				}else{
					last_high_depth += rs[i].offset + rs[i].diameter;
				}

			}

		}

		return "ERROR";
	}.bind(this);

	this.createReoInput = function(){
		var nr = new ReoInput();
		nr.manager = this;
		console.log("fix events")
		nr.on("update",this.update);
		nr.on("change",this.change);
		return nr;
	}.bind(this);

	this.change = function(e){
		//console.log("reo-manager change");
		this.dispatch("change",this);
	}.bind(this);

	this.update = function(e){
		//console.log("reo-manager update");
		this.dispatch("update",this);
	}.bind(this);

	Object.defineProperty(this,"value",{

		get:function(){
			var result = [];
			var rs = this.getEnabledRows(); 
			var rw;

			for(var i = 0;i<rs.length;i++){

				rw = {
					number:		rs[i].number,
					diameter:	rs[i].diameter,
					area:			rs[i].area,
					depth:		this.getDepthOfRow(rs[i])
				}

				result.push(rw);
			}

			return result;
		},

		set:function(newval){
			// TODO: DESERIELIZEEEE :|
		}

	});

	Object.defineProperty(this,"selected_value",{

		get:function(){
			var result = [];
			var rs = this.getEnabledSelectedRows(); 
			var rw;

			for(var i = 0;i<rs.length;i++){

				rw = {
					number:		rs[i].number,
					diameter:	rs[i].diameter,
					area:			rs[i].area,
					depth:		this.getDepthOfRow(rs[i]),
					mass_per_meter:	rs[i].mass_per_meter,
					from:			rs[i].from,
					offset:			rs[i].offset,
				}

				result.push(rw);
			}

			return result;
		},

		set:function(newval){
			// TODO: DESERIELIZEEEE :|
		}

	});
	this.create();
};var rman = new ReoManager(document.querySelector("#reorows"));
rman.on("change",mainUpdateListener);

for(var i in vin){
	vin[i].appendTo(document.querySelector("#invardivdiv"));
	vin[i].on("change",mainUpdateListener);
}

// Create global beam object
var b = new Beam();

function intakeBeamValues(){
	b.Ln		= vin.Ln.value;
	b.b		= vin.b.value;
	b.D		= vin.D.value;
	b.cover	= vin.cover.value;
	b.eclass	= vin.eclass.value;
	b.df		= vin.df.value;
	b.rhoc	= vin.rhoc.value;
	b.fc		= vin.fc.value;
	b.reo		= rman.value;
}


function outputCalculations(){

	function f(n){

		if(typeof n == "number" && !isNaN(n)){
			return n.toFixed(0)

		}else{
			return "--"
		}

	}

	var calc = [];
	calc.push("alpha2: "	+b.alpha2.toFixed(2)		);
	calc.push("gamma: "	+b.gamma.toFixed(2)		);
	calc.push("");
	calc.push("dn: "	+f(b.dn)+" mm"		);
	calc.push("Muo: "	+f(b.Muo)+" kNm");
	calc.push("Muo min: "	+f(b.Muo_min)+" kNm");
	calc.push("Ast min (Alternative to meeting Muo_min): "	+f(b.Muo_min_Ast_min)+" mm^2");
	calc.push("");
	calc.push("Ag: "	+f(b.Ag)+" mm^2");
	calc.push("Ast: "	+f(b.Ast)+" mm^2");
	calc.push("Asc: "	+f(b.Asc)+" mm^2");
	calc.push("Acc: "	+f(b.Acc)+" mm^2");
	calc.push("Ixx: "	+f(b.Ixx)+" mm^4");
	calc.push("Ze: "	+f(b.Ze)+" mm^3");
	calc.push("Tensile reo ratio (Ast/Ag): "	+(b.p*100).toFixed(3)+"%");
	calc.push("");
	calc.push("Ts: "	+f(b.Ts)		);
	calc.push("Cs: "	+f(b.Cs)		);
	calc.push("Cc: "	+f(b.Cc)		);
	calc.push("");
	calc.push("Ts_centroid_depth: "	+ f(b.Ts_centroid_depth)		);
	calc.push("Cs_centroid_depth: "	+ f(b.Cs_centroid_depth)		);
	calc.push("Cc_centroid_depth: "	+ 	  f(b.Cc_centroid_depth)		);
	calc.push("");
	document.querySelector("#calcdivcontent").innerHTML = calc.join("<br>");
	var o = document.createElement("pre");
	o.innerHTML = "Beam Information "+JSON.stringify(b,undefined,4);
	document.querySelector("#calcdivcontent").appendChild(o);
}


function outputReoSummary(){
	// TODO: fix this bs :(
	return
	var rm = document.querySelector("reo-manager");
	var om = document.querySelector("reo-output");
	var rs = rman.selected_value;

	if(rs.length == 0){
		om.clear();
		om.oneLables();
		return;

	}else if(rs.length>1){
		om.avgLables();

	}else{
		om.oneLables();
	}

	var area = 0;
	var depth_times_area = 0;
	var number = 0;
	var length = 0;
	var mass = 0;
	var tforce = 0;

	for(var i = 0;i<rs.length;i++){
		area += rs[i].area;
		depth_times_area += rs[i].depth*rs[i].area;
		number += rs[i].number;
		length += rs[i].number*b.Ln/1000;
		mass += rs[i].number*b.Ln/1000*rs[i].mass_per_meter;
		tforce += b.layer_force_from_layer_dn(rs[i], b.dn);
	}

	// TODO: remove the "Amount:" lable and lable individualy.
	// TODO: fix output styles to prevent column resizing
	// TODO: have a current column and sum column??
	om.setIdContent("depth", (depth_times_area/area).toFixed(0) || 0);
	om.setIdContent("area", area);
	om.setIdContent("number", number);
	om.setIdContent("length", length.toFixed(1));
	om.setIdContent("mass", mass.toFixed(1));
	om.setIdContent("tforce", tforce.toFixed(1));
}

var cs_canvas = document.querySelector("#crosssectioncanvas");
var cs_ctx = cs_canvas.getContext('2d');
mainUpdateListener()

function mainUpdateListener(e){
	DoValidation(); // see validation.js
	intakeBeamValues();
	outputCalculations();
	outputReoSummary();
	drawCrossSection(cs_ctx,b)
}

//###########################################################################################
//###### validation error text box ###########################################################
//###########################################################################################

function setErrorList(list){

	if(list===undefined || list.length==0){
		document.querySelector("#errortr").style.display="none";

	}else{
		document.querySelector("#errortr").style.display="";
		var out = '<h1 style="color:darkred;">Error</h1>'

		for(var i = 0;i<list.length;i++){
			out+="<p>"+list[i]+"</p>";
		}

		document.querySelector("#errortd").innerHTML = out;
	}

}

//##################################################################3
//##### Tooltips ###################################################3
//##################################################################3

setTimeout(function(){
	addTooltipTo(document.querySelector("#invardiv"),document.querySelector("#invardivtooltipbar"));
	addTooltipTo(document.querySelector("#reoinputoutputdiv"),document.querySelector("#reoinputoutputtooltipbar"));
},1500);

function addTooltipTo(d, output){
	var els = d.querySelectorAll("*");

	for(var i = 0;i<els.length;i++){

		if(els[i].webkitShadowRoot!=null){
			addTooltipTo(els[i].webkitShadowRoot, output);
			//console.log(els[i]);

		}else if(els[i].getAttribute("data-tooltip")){
			els[i].output = output;

			els[i].addEventListener("mouseover",function(e){
				var targ = e.target; 

				while(targ.getAttribute("data-tooltip")===null){
					targ=targ.parentNode;
				}

				var ttb = this.output;
				ttb.innerHTML = "Pro-tip: "+targ.getAttribute("data-tooltip");
			}.bind(els[i]));

			els[i].addEventListener("mouseout",function(e){
				var ttb = this.output;
				ttb.innerHTML = "";
			}.bind(els[i]));
		}

	}

}

//##########################################################
//#### iFrame Scroll behaviour #############################
//##########################################################
var scroll_disabled = false;

document.querySelector("#varinfoiframe").addEventListener("mouseover",function(e){

	try{

		if(e.target.contentDocument.body.scrollHeight> e.target.contentDocument.body.clientHeight){
			scroll_disabled = true;
		}


	}catch(e){
		//	console.warn("iFrame Scroll prevention doesnt work :(");
		//fail silently
	}

});

document.querySelector("#varinfoiframe").addEventListener("mouseout",function(e){
	scroll_disabled = false;
	document.querySelector("#varinfoiframe").style.borderColor="";
});

document.body.addEventListener("mousewheel",function(e){

	if(scroll_disabled){
		e.preventDefault();

		try{
			document.querySelector("#varinfoiframe").style.borderColor="orange";

			setTimeout(function(){
				document.querySelector("#varinfoiframe").style.borderColor="";
			},200);

		}catch(e){
			//	console.warn("iFrame Scroll prevention doesnt work :(");
			// fail silently
		}

	}

});
//##########################################################
//#### Contextual Help View ################################
//##########################################################

(function(){
	var xins = document.querySelectorAll("x-input");

	for(var i = 0;i<xins.length;i++){

		xins[i].addEventListener("mousedown",function(e){
			setHelpLoc("infos/"+e.target.id+".htm");
		})
	}

})()
var _current_help_url = "";

function setHelpLoc(url){
	// console.log(_current_help_url,document.querySelector("#varinfoiframe").contentWindow.location.pathname)
	// console.log(document.querySelector("#varinfoiframe").getAttribute("src"),url)
	// console.log(_current_help_url === document.querySelector("#varinfoiframe").contentWindow.location.pathname)
	// console.log(document.querySelector("#varinfoiframe").getAttribute("src") === url)
	if(document.querySelector("#varinfoiframe").contentWindow.location.pathname !== _current_help_url ||

			document.querySelector("#varinfoiframe").getAttribute("src")!==url){

		document.querySelector("#varinfoiframe").onload = function(){
			_current_help_url = document.querySelector("#varinfoiframe").contentWindow.location.pathname;
		};
		document.querySelector("#varinfoiframe").setAttribute("src",url);
	}

}

var ifrm = document.querySelector("#varinfoiframe");
var rm = document.querySelector("reo-manager");</script>
	</html>
			<!--
		<div id="elevationdiv" class="bmpblock" style="display:flex;flex-wrap:wrap;">
			<h1 style="display:block;width:100%">Elevation</h1>
			<div style="width:100%;">
				<canvas id="elevationcanvas" style="background-color:black;"></canvas>
			</div>
		</div>
		-->
	<!--
				<x-input	id="Ln"		
							notation ="$$$L_n$$$" 
							unit="mm"
							value="1000"
							type="number"
							min="0"
							max="50000"
							step="500"
							data-tooltip="Clear Span from edge to edge of supports"></x-input>
				<x-input	id="b"
							notation ="$$$b$$$"
							unit="mm"
							value="300"
							type="number"
							min="200"
							max="5000"
							step="5"
							data-tooltip="Breadth (horizontal width) of rectangular beam cross section"></x-input>
				<x-input	id="D"
							notation ="$$$D$$$"
							unit="mm"
							value="600"
							type="number"
							min="0"
							max="10000"
							step="10"
							data-tooltip="Total depth (vertical height) of beam from top to bottom surface"></x-input>
				<x-input	id="cover"
							notation ="$$$\text{Cover}$$$"
							unit="mm"
							value="25"
							type="number"
							min="20"
							max="100"
							step="5"
							data-tooltip="Distance from the outer surface of concrete to the reo bars (all around)"></x-input>
				<x-input	id="eclass"
							notation ="$$$\text{E. Class}$$$"
							options='["A1","A2","B1","B2","C1","C2"]'
							pattern="(A|B|C|D)"
							data-tooltip="Exposure Classification determined by exposure to natural environment. See AS3600 Table 4.3."></x-input>
				<x-input	id="df"
							notation="$$$d_f$$$"
							unit="mm"
							value="10"
							options="[10, 12, 16, 20, 24, 28, 32, 36, 40]"
							data-tooltip="Diameter of fitment bars (the 'ribcage') of the beam. Standard nominal diameters: [10, 12, 16, 20, 24, 28, 32, 36, 40]mm"></x-input> 
				<x-input	id="rhoc"
							notation="$$$\rho_c$$$"
							unit="kg/m&#179;"
							value="2400"
							type="number"
							min="2100"
							max="2800"
							step="10"
							data-tooltip="Concrete Density"></x-input>
				<x-input	id="fc"
							notation="$$$f'_c$$$"
							unit="MPa"
							value="32"
							options="[20, 25, 32, 40, 50, 65, 80, 100]"
							data-tooltip="Concrete Strength. This software only uses standard grades."></x-input>
					-->